% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captions{\renewcommand{\figurename}{图 }}
\addto\captions{\renewcommand{\tablename}{表 }}
\floatname{literal-block}{列表 }


\usepackage{xeCJK}
\usepackage{indentfirst}
\setlength{\parindent}{2em}
\setCJKmainfont[BoldFont=SimHei, ItalicFont=STKaiti]{SimSun}
\setCJKmonofont[Scale=0.9]{SimHei}
\setCJKfamilyfont{song}[BoldFont=SimSun]{SimSun}
\setCJKfamilyfont{sf}[BoldFont=SimSun]{SimSun}


\title{Python 简介文档}
\date{2015-11-02}
\release{3.6}
\author{冯龙辉}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{发布}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}

\begin{quote}\begin{description}
\item[{Release}] \leavevmode
3.6

\item[{Date}] \leavevmode
2015-11-01

\end{description}\end{quote}

Python 是一门简单易学且功能强大的编程语言。它拥有高效的高级数据结构，并且能够用简单而又高效的方式进行面向对象编程。
Python 优雅的语法和动态类型，再结合它的自然语言的解释，使其在大多数平台的许多领域成为编写脚本或开发应用程序的理想语言。

你可以自由地从 Python 官方网点: \href{http://www.python.org}{http://www.python.org}，以源代码或二进制形式获取 Python 解释器以及其标准扩展库，
并可以自由的分发。此站点同时也提供了大量的第三方 Python 模块、程序和工具，以及附加文档。

你可以很容易的使用 C 或 C++ 为 Python 解释器扩展新函数和数据类型。
Python 还可以被用作定制应用程序的一门扩展语言。

本手册非正式的向读者介绍了 Python 语言及其体系相关的基本知识与概念。
在学习实践中结合使用 Python 解释器是很有帮助的，由于所有的例子都是完整的，所以本手册亦可离线阅读。

如果需要了解相关标准库或对象的详细介绍，请查阅 \href{https://docs.python.org/3/library/index.html\#library-index}{Python 参考文档} 。\href{https://docs.python.org/3/reference/index.html\#reference-index}{Python 参考手册} 提供了更多语言相关的正式说明。
如果想要使用 C 或 C++ 编写扩展，请查阅 \href{https://docs.python.org/3/extending/index.html\#extending-index}{Python 解释器扩展和集成章节} 和 \href{https://docs.python.org/3/c-api/index.html\#c-api-index}{C API 参考手册} 。
当然也可阅读一些深入介绍 Python 知识的图书。

本手册不会尝试涵盖 Python 的全部知识和每个特性，甚至不会涵盖所有常用的特性。
相反地，它会介绍 Python 中许多最引人瞩目的特性，并且会给你一个关于语言特色和风格的认识。
读完之后，你将能够阅读和编写 Python 模块或程序，并为以后使用
\href{https://docs.python.org/3/reference/index.html\#reference-index}{Python 参考手册} 继续学习诸多 Python 模块库做好准备。

\href{https://docs.python.org/3/glossary.html\#glossary}{词汇表} 也值得浏览一下。


\chapter{开胃菜}
\label{appetite:python}\label{appetite:tutorial-index}\label{appetite::doc}\label{appetite:id1}\label{appetite:tut-intro}
如果你要用计算机做很多工作，最后你会发现有一些任务你更希望用自动化的方式进行处理。比如，你想要在大量的文本
文件中执行查找/替换，或者以复杂的方式对大量的图片进行重命名和整理。也许你想要编写一个小型的自定义数据库、一
个特殊的 GUI 应用程序或一个简单的小游戏。

如果你是一名专业的软件开发者，可能你必须使用几种 C/C++/JAVA 类库，并且发现通常编写/编译/测试/重新编译的周期
是如此漫长。也许你正在为这些类库编写测试用例，但是发现这是一个让人烦躁的工作。又或者你已经完成了一个可以使用
扩展语言的程序，但你并不想为此重新设计并实现一套全新的语言。

那么 Python 正是你所需要的语言。

虽然你能够通过编写 Unix shell 脚本或 Windows 批处理文件来处理其中的某些任务，由于 Shell 脚本更适合移动文件或
修改文本数据，并不适合编写 GUI 应用程序或游戏；虽然你能够使用 C/C++/JAVA 编写这样的程序，但即使编写一个简单
的 first-draft 程序也有可能耗费大量的开发时间。相比之下，Python 更易于使用，无论在 Windows、Mac OS X 或 Unix 操
作系统上它都会帮助你更快地完成任务。

虽然 Python 易于使用，但它却是一门完整的编程语言；与 Shell 脚本或批处理文件相比，它支持编写大型程序并提供了更多
的数据结构。另一方面，Python 提供了比 C 更多的错误检查，并且作为一门 \emph{高级语言}，它内置了高级的数据结构类型，例
如：灵活的数组和字典。因其更多的通用数据类型，Python 比 Awk 甚至 Perl 都适用于更多问题领域，至少做大多数事情
在 Python 中比其他语言要简单。

Python 允许你将程序分割为不同的模块，以便在其他的 Python 程序中重用。Python 内置提供了大量的标准模块，你可以将其
用作编写程序的基础，或者作为学习 Python 编程的示例。这些模块提供了诸如文件 I/O、系统调用、Socket ，甚至类似 Tk 的
用户图形界面（GUI）工具包接口。

Python 是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python 解释器可以交互的使用，这使得
体验语言的特性、编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。

Python 让程序编写的更紧凑和可读。用 Python 编写的程序通常比同样的 C、C++ 或 Java 程序更短小，这是因为以下几个原因:

\begin{Verbatim}[commandchars=\\\{\}]
* 高级数据结构使你可以在一条语句中表达复杂的操作；

* 语句组使用缩进代替开始和结束大括号来组织；

* 变量或参数无需声明。
\end{Verbatim}

Python 是 \emph{可扩展} 的：如果你会 C 语言编程便可以轻易地为解释器添加内置函数或模块，扩展还可以是对性能瓶颈做优化，或者
将 Python 程序与只有二进制形式的库（比如某个专业的商业图形库）连接起来。一旦你真正掌握了它，你可以将 Python 解释
器集成进某个 C 应用程序，并把它当作那个程序的扩展或命令行语言。

顺便说一句，这个语言的名字来自于 BBC 的 “Monty Python’s Flying Cirecus” 节目，和爬行类动物没有任何关系。在文档中
引用 Monty Python 的典故不仅可行，而且值得鼓励！

现在你已经为 Python 兴奋不已了吧，大概想要领略一些更多的细节！学习一门语言最好的方法就是使用它，本指南推荐你边读边
使用 Python 解释器练习。

下一节中，我们将解释 Python 解释器的用法。这些只是一些很简单的信息，但它有助于练习后面的例子。

本手册剩下的部分将通过示例介绍 Python 语言及系统的诸多特性，开始是简单的语法、数据类型和表达式，接着介绍函数与模块，
最后涉及异常和自定义类这样的高级内容。


\chapter{使用 Python 解释器}
\label{interpreter:tut-using}\label{interpreter:python}\label{interpreter::doc}

\section{调用解释器}
\label{interpreter:tut-invoking}\label{interpreter:id1}
在机器允许访问的情况下，Python 解释器通常被安装在 \code{/usr/local/bin/python3.6} 目录下。
为了在shell中能够通过下面的命令启动解释器， 需要将 \code{/usr/local/bin} 目录包含进 Unix shell 的
搜索路径里:

\begin{Verbatim}[commandchars=\\\{\}]
python3.6
\end{Verbatim}

\footnote{
在 Unix 系统上，Python 3.X 解释器默认未被安装成名为 \code{python} 的命令，所以它不会与
同时安装在系统中的 Python 2.x 命令冲突。
} 由于 Python 解释器的安装路径是可选的，这也可能是其它路径，你可以联系安装 Python 的用户或
系统管理员确认（例如，\code{/usr/local/python} 就是一个常见的选择）。

在 Windows 机器上，Python 通常安装在 \code{C:\textbackslash{}Python36} 位置，当然你可以在运行安装向导时修改
此值。要想把此目录添加到你的 PATH 环境变量中，你可以在 DOS 窗口中输入以下命令:

\begin{Verbatim}[commandchars=\\\{\}]
set path=\PYGZpc{}path\PYGZpc{};C:\PYGZbs{}python36
\end{Verbatim}

通常你可以在主窗口输入一个文件结束符（Unix 系统是 \code{Control-D}，Windows 系统是 \code{Control-Z}）
让解释器以 0 状态码退出。如果那没有作用，你可以通过输入 \code{quit()} 命令退出解释器。

在支持读行的机器上， Python 解释器支持交互编辑， 历史记录和代码自动完成功能。通常在出现python窗口
的地方，输入 \code{Control-P} 来快速检查是否支持命令行编辑。如果发出嘟嘟声，则说明你可以使用命令行编辑功能；
更多快捷键的介绍请参考 {\hyperref[interactive:tut-interacting]{\emph{\DUspan{}{交互式输入行编辑和历史回溯}}}} (\autopageref*{interactive:tut-interacting})。如果没有任何声音，或者显示 \code{\textasciicircum{}P} 字符，则说明命令行
编辑功能不可用；你只能通过退格键从当前行删除已键入的字符并重新输入。

Python 解释器有些操作类似 Unix shell：当使用终端设备（tty）作为标准输入调用时，它交互的解释并执行命令；
当使用文件名参数或以文件作为标准输入调用时，它读取文件并将文件作为 \emph{脚本} 执行。

第二种启动 Python 解释器的方法是 \code{python -c command {[}arg{]} ...}，这种方法可以在 \emph{命令行} 执行 Python 语句，
类似于 shell 中的 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-c}{-c} 选项。由于 Python 语句通常会包含空格或其他特殊 shell 字符，一般建议将 \emph{命令} 用单引号包裹起来。

有一些 Python 模块也可以当作脚本使用。你可以使用 \code{python -m module {[}arg{]} ...} 命令调用它们，这类似在命令行
中键入完整的路径名执行 \emph{模块} 源文件一样。

使用脚本文件时，经常会运行脚本然后进入交互模式。这也可以通过在脚本之前加上 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-i}{-i} 参数来实现。


\subsection{参数传递}
\label{interpreter:id3}\label{interpreter:tut-argpassing}
调用解释器时，脚本的名字和附加其后的参数转换为一个字符串列表，然后赋值给 \code{sys} 模块中的 \code{argv} 变量，
你可以通过执行 \code{import sys} 获得这个列表。列表的最少长度为1；当没有提供脚本和参数的时候， \code{sys.argv{[}0{]}} 是
一个空字符串。当给定了脚本的名字如 \code{'-'} （表示标准输入）时， \code{sys.argv{[}0{]}} 被设定为 \code{'-'} 。
使用 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-c}{-c} \emph{指令} 时， \code{sys.argv{[}0{]}} 被设定为 \code{'-c'} 。使用 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-m}{-m} \emph{模块} 参数时，\code{sys.argv{[}0{]}} 被设定
为指定模块的全名。 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-c}{-c} \emph{指令} 或者 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-m}{-m} \emph{模块} 之后的参数不会被 Python 解释器的选项处理机制所截获，
而是留在 \code{sys.argv} 中，供脚本命令操作。


\subsection{交互模式}
\label{interpreter:id4}\label{interpreter:tut-interactive}
从 tty 读取命令时，我们称解释器工作于 \emph{交互模式}。这种模式下它根据主提示符来执行，主提示符通常标识为三个大于号 (\code{\textgreater{}\textgreater{}\textgreater{}}) ；
继续的部分被称为 \emph{从属提示符}，默认为三个点标识 (\code{...}) 。在第一行之前，解释器打印欢迎信息、版本号和授权提示:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python3.6
Python 3.6 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type \PYGZdq{}help\PYGZdq{}, \PYGZdq{}copyright\PYGZdq{}, \PYGZdq{}credits\PYGZdq{} or \PYGZdq{}license\PYGZdq{} for more information.
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{Verbatim}

输入多行结构时需要从属提示符，例如，下面这个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 语句:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{the\PYGZus{}world\PYGZus{}is\PYGZus{}flat} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{if} \PYG{n}{the\PYGZus{}world\PYGZus{}is\PYGZus{}flat}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Be careful not to fall off!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{Be careful not to fall off!}
\end{Verbatim}

关于交互模式更多的内容，请参见 {\hyperref[appendix:tut-interac]{\emph{\DUspan{}{交互模式}}}} (\autopageref*{appendix:tut-interac})。


\section{解释器及其环境}
\label{interpreter:tut-interp}\label{interpreter:id5}

\subsection{源程序编码}
\label{interpreter:id6}\label{interpreter:tut-source-encoding}
默认情况下，Python 源文件是 UTF-8 编码。在此编码下，全世界大多数语言的字符可以同时用在字符串、标识符
和注释中 --- 尽管 Python 标准库仅使用 ASCII 字符做为标识符，这只是任何可移植代码应该遵守的约定。
如果要正确的显示所有的字符，你的编辑器必须能识别出文件是 UTF-8 编码，并且它使用的字体能支持文件中所有的字符。

你也可以为源文件指定不同的字符编码。为此，在 \code{\#!} 行后插入至少一行特殊的注释行来定义源文件的编码:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} \PYGZhy{}*\PYGZhy{} coding: encoding \PYGZhy{}*\PYGZhy{}
\end{Verbatim}

通过此声明，源文件中所有的字符都会被当做用 \emph{encoding} 指代的 UTF-8 编码对待。在 Python 库参考手册 \href{https://docs.python.org/3/library/codecs.html\#module-codecs}{codecs} 一
节中你可以找到一张可用的编码列表。

例如，如果你的编辑器不支持 UTF-8 编码的文件，但支持像 Windows-1252 的其他一些编码，你可以定义:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} \PYGZhy{}*\PYGZhy{} coding: cp\PYGZhy{}1252 \PYGZhy{}*\PYGZhy{}
\end{Verbatim}

这样就可以在源文件中使用 Windows-1252 字符集中的所有字符了。这个特殊的编码注释必须在文件中的 \emph{第一或第二} 行定义。


\chapter{Python 简介}
\label{introduction:python}\label{introduction:codecs}\label{introduction::doc}\label{introduction:tut-informal}
下面的例子中，输入和输出分别由大于号和句号提示符（ \code{\textgreater{}\textgreater{}\textgreater{}} 和 \code{...} ）标注：如果想要重现这些例子，
就要在解释器的提示符后，输入那些不包含提示符的代码行。需要注意的是在练习中遇到的
从属提示符表示你需要在最后多输入一个空行，解释器才能知道这是一个多行命令的结束。

本手册中的很多示例，包括那些带有交互提示符的，都含有注释。Python 中的注释以 \code{\#} 字符开头，
直至实际的行尾（译者注——这里原作者用了 physical line 以表示实际的换行而非编辑器的自动换行）。
注释可以从行首开始，也可以在空白处或代码之后，但是不出现在字符串中。文本字符串中的 \code{\#} 字符仅仅表示 \code{\#} 。
代码中的注释不会被 Python 解释，录入示例的时候可以忽略它们。

如下示例:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} this is the first comment}
\PYG{n}{spam} \PYG{o}{=} \PYG{l+m+mi}{1}  \PYG{c}{\PYGZsh{} and this is the second comment}
          \PYG{c}{\PYGZsh{} ... and now a third!}
\PYG{n}{text} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsh{} This is not a comment because it}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s inside quotes.}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}


\section{将 Python 当做计算器}
\label{introduction:tut-calculator}\label{introduction:id1}
我们来尝试一些简单的 Python 命令。启动解释器然后等待主提示符 \code{\textgreater{}\textgreater{}\textgreater{}} 出现（不需要很久）。


\subsection{数字}
\label{introduction:id2}\label{introduction:tut-numbers}
解释器表现得就像一个简单的计算器：可以向其录入一些表达式，它会给出返回值。表达式语法很直白：
运算符 \code{+}，\code{-}，\code{*} 和 \code{/} 与其它语言一样(例如：Pascal 或 C)；括号 (\code{()}) 用于分组。
例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{2}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{50} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{l+m+mi}{6}
\PYG{g+go}{20}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{l+m+mi}{50} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{4}
\PYG{g+go}{5.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{8} \PYG{o}{/} \PYG{l+m+mi}{5}  \PYG{c}{\PYGZsh{} division always returns a floating point number}
\PYG{g+go}{1.6}
\end{Verbatim}

整数(例如，\code{2}， \code{4}， \code{20} )的类型是 \href{https://docs.python.org/3/library/functions.html\#int}{int}，带有小数部分的数字(例如，\code{5.0}， \code{1.6})的类型是 \href{https://docs.python.org/3/library/functions.html\#float}{float}。
在本教程的后面我们会看到更多关于数字类型的内容。

除法 (\code{/}) 永远返回一个浮点数。如要使用 \href{https://docs.python.org/3/glossary.html\#term-floor-division}{地板除法} 并且得到整数结果（丢掉任何小数部分），你可以使用 \code{//} 运算符；
要计算余数你可以使用 \code{\%}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{17} \PYG{o}{/} \PYG{l+m+mi}{3}  \PYG{c}{\PYGZsh{} classic division returns a float}
\PYG{g+go}{5.666666666666667}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{17} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{3}  \PYG{c}{\PYGZsh{} floor division discards the fractional part}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{17} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3}  \PYG{c}{\PYGZsh{} the \PYGZpc{} operator returns the remainder of the division}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{2}  \PYG{c}{\PYGZsh{} result * divisor + remainder}
\PYG{g+go}{17}
\end{Verbatim}

通过 Python，还可以使用 \code{**} 运算符计算幂乘方 \footnote{
因为 \code{**} 的优先级高于 \code{-}，所以 \code{-3**2} 将解释为 \code{-(3**2)} 且结果为 \code{-9}。为了避免这点
并得到 \code{9}，你可以使用 \code{(-3)**2}。
}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{5} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}  \PYG{c}{\PYGZsh{} 5 squared}
\PYG{g+go}{25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{7}  \PYG{c}{\PYGZsh{} 2 to the power of 7}
\PYG{g+go}{128}
\end{Verbatim}

等号 ( \code{'='} ) 用于给变量赋值。赋值之后，在下一个提示符之前不会有任何结果显示:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{width} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{height} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{l+m+mi}{9}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{width} \PYG{o}{*} \PYG{n}{height}
\PYG{g+go}{900}
\end{Verbatim}

变量在使用前必须 ``定义''(赋值)，否则会出错:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} try to access an undefined variable}
\PYG{g+gp}{... }\PYG{n}{n}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
\PYG{g+gr}{NameError}: \PYG{n}{name \PYGZsq{}n\PYGZsq{} is not defined}
\end{Verbatim}

浮点数有完整的支持；整数和浮点数的混合计算中，整数会被转换为浮点数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+m+mf}{3.75} \PYG{o}{/} \PYG{l+m+mf}{1.5}
\PYG{g+go}{7.5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{7.0} \PYG{o}{/} \PYG{l+m+mi}{2}
\PYG{g+go}{3.5}
\end{Verbatim}

交互模式中，最近一个表达式的值赋给变量 \code{\_}。这样我们就可以把它当作一个桌面计算器，很方便的用于连续计算，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tax} \PYG{o}{=} \PYG{l+m+mf}{12.5} \PYG{o}{/} \PYG{l+m+mi}{100}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{price} \PYG{o}{=} \PYG{l+m+mf}{100.50}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{price} \PYG{o}{*} \PYG{n}{tax}
\PYG{g+go}{12.5625}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{price} \PYG{o}{+} \PYG{n}{\PYGZus{}}
\PYG{g+go}{113.0625}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{113.06}
\end{Verbatim}

此变量对于用户是只读的。不要尝试给它赋值 --- 你只会创建一个独立的同名局部变量，它魔术般的屏蔽了系统的内置变量。

除了 \href{https://docs.python.org/3/library/functions.html\#int}{int} 和 \href{https://docs.python.org/3/library/functions.html\#float}{float}，Python 还支持其它数字类型，例如 \href{https://docs.python.org/3/library/decimal.html\#decimal.Decimal}{Decimal} 和 \href{https://docs.python.org/3/library/fractions.html\#fractions.Fraction}{Fraction}。Python 还内建支持 \href{https://docs.python.org/3/library/stdtypes.html\#typesnumeric}{复数} ，使
用后缀 \code{j} 或 \code{J} 表示虚数部分（例如，\code{3+5j} ）。


\subsection{字符串}
\label{introduction:tut-strings}\label{introduction:id4}
相比数值，Python 也提供了可以通过几种不同方式表示的字符串。它们可以用单引号 (\code{'...'}) 或双引号 (\code{"..."})  标
识符 \footnote{
与其它语言不同，特殊字符例如 \code{\textbackslash{}n} 在单引号(\code{'...'})和双引号(\code{"..."})中具有相同的含义。
两者唯一的区别是在单引号中，你不需要转义 \code{"} （但你必须转义 \code{\textbackslash{}'} )，反之亦然。
}。\code{\textbackslash{}} 可以用来转义引号:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam eggs}\PYG{l+s}{\PYGZsq{}}  \PYG{c}{\PYGZsh{} single quotes}
\PYG{g+go}{\PYGZsq{}spam eggs\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doesn}\PYG{l+s+se}{\PYGZbs{}\PYGZsq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZsq{}}  \PYG{c}{\PYGZsh{} use \PYGZbs{}\PYGZsq{} to escape the single quote...}
\PYG{g+go}{\PYGZdq{}doesn\PYGZsq{}t\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{doesn}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}  \PYG{c}{\PYGZsh{} ...or use double quotes instead}
\PYG{g+go}{\PYGZdq{}doesn\PYGZsq{}t\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Yes,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ he said.}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}\PYGZdq{}Yes,\PYGZdq{} he said.\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{Yes,}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ he said.}\PYG{l+s}{\PYGZdq{}}
\PYG{g+go}{\PYGZsq{}\PYGZdq{}Yes,\PYGZdq{} he said.\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Isn}\PYG{l+s+se}{\PYGZbs{}\PYGZsq{}}\PYG{l+s}{t,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ she said.}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}\PYGZdq{}Isn\PYGZbs{}\PYGZsq{}t,\PYGZdq{} she said.\PYGZsq{}}
\end{Verbatim}

在交互解释器中，输出的字符串会用引号引起来，特殊字符会用反斜杠转义。虽然可能和输入看上去不太一样，
但是两个字符串是相等的。如果字符串中只有单引号而没有双引号，就用双引号引用，否则用单引号引用。\href{https://docs.python.org/3/library/functions.html\#print}{print()} 函数
生成可读性更好的输出, 它会省去引号并且打印出转义后的特殊字符：

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Isn}\PYG{l+s+se}{\PYGZbs{}\PYGZsq{}}\PYG{l+s}{t,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ she said.}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}\PYGZdq{}Isn\PYGZbs{}\PYGZsq{}t,\PYGZdq{} she said.\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Isn}\PYG{l+s+se}{\PYGZbs{}\PYGZsq{}}\PYG{l+s}{t,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ she said.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{}Isn\PYGZsq{}t,\PYGZdq{} she said.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{First line.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Second line.}\PYG{l+s}{\PYGZsq{}}  \PYG{c}{\PYGZsh{} \PYGZbs{}n means newline}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s}  \PYG{c}{\PYGZsh{} without print(), \PYGZbs{}n is included in the output}
\PYG{g+go}{\PYGZsq{}First line.\PYGZbs{}nSecond line.\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}  \PYG{c}{\PYGZsh{} with print(), \PYGZbs{}n produces a new line}
\PYG{g+go}{First line.}
\PYG{g+go}{Second line.}
\end{Verbatim}

如果你不想前面带有 \code{\textbackslash{}} 的字符被当作特殊字符，你可以使用 \emph{原始字符串}，方法是在第一个引号前面加上一个 \code{r}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{C:}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{some}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ame}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} here \PYGZbs{}n means newline!}
\PYG{g+go}{C:\PYGZbs{}some}
\PYG{g+go}{ame}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{r\PYGZsq{}}\PYG{l+s}{C:}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{some}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} note the r before the quote}
\PYG{g+go}{C:\PYGZbs{}some\PYGZbs{}name}
\end{Verbatim}

字符串文本能够分成多行。一种方法是使用三引号：\code{"""..."""} 或者 \code{'{'}'...'{'}'}。行尾换行符会被自动包含到字符串中，
但是可以在行尾加上 \code{\textbackslash{}} 来避免这个行为。看下面的示例:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{Usage: thingy [OPTIONS]}
\PYG{l+s}{     \PYGZhy{}h                        Display this usage message}
\PYG{l+s}{     \PYGZhy{}H hostname               Hostname to connect to}
\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

将生成以下输出（注意，没有开始的第一行）:

\begin{Verbatim}[commandchars=\\\{\}]
Usage: thingy [OPTIONS]
     \PYGZhy{}h                        Display this usage message
     \PYGZhy{}H hostname               Hostname to connect to
\end{Verbatim}

字符串可以由 \code{+} 操作符连接(粘到一起)， \code{*} 操作符重复:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} 3 times \PYGZsq{}un\PYGZsq{}, followed by \PYGZsq{}ium\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{un}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ium}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}unununium\PYGZsq{}}
\end{Verbatim}

相邻的两个字符串文本自动连接在一起。:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Py}\PYG{l+s}{\PYGZsq{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{thon}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}Python\PYGZsq{}}
\end{Verbatim}

它只用于两个字符串文本，不能用于字符串表达式:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{prefix} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Py}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{prefix} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{thon}\PYG{l+s}{\PYGZsq{}}  \PYG{c}{\PYGZsh{} can\PYGZsq{}t concatenate a variable and a string literal}
\PYG{g+go}{  ...}
\PYG{g+go}{SyntaxError: invalid syntax}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{un}\PYG{l+s}{\PYGZsq{}} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ium}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{  ...}
\PYG{g+go}{SyntaxError: invalid syntax}
\end{Verbatim}

如果你想连接多个变量或者连接一个变量和一个字符串文本，使用 \code{+}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{prefix} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{thon}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}Python\PYGZsq{}}
\end{Verbatim}

下面这个功能在你想切分很长的字符串的时候特别有用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{text} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Put several strings within parentheses }\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{            \PYGZsq{}to have them joined together.\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{text}
\PYG{g+go}{\PYGZsq{}Put several strings within parentheses to have them joined together.\PYGZsq{}}
\end{Verbatim}

字符串也可以被 \emph{索引的} (下标)。类似于 C ，字符串的第一个字符索引为 0 。Python 没有单独的字符类型；
一个字符就是一个简单的长度为1的字符串。:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Python}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}  \PYG{c}{\PYGZsh{} character in position 0}
\PYG{g+go}{\PYGZsq{}P\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}  \PYG{c}{\PYGZsh{} character in position 5}
\PYG{g+go}{\PYGZsq{}n\PYGZsq{}}
\end{Verbatim}

索引也可以是负数，用来从右边开始计算。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c}{\PYGZsh{} last character}
\PYG{g+go}{\PYGZsq{}n\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c}{\PYGZsh{} second\PYGZhy{}last character}
\PYG{g+go}{\PYGZsq{}o\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}P\PYGZsq{}}
\end{Verbatim}

请注意 -0 实际上就是 0，所以它不会导致从右边开始计算。

除了索引，还支持 \emph{切片} 。索引用于获得单个字符，\emph{切片} 让你获得一个子字符串:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c}{\PYGZsh{} characters from position 0 (included) to 2 (excluded)}
\PYG{g+go}{\PYGZsq{}Py\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}  \PYG{c}{\PYGZsh{} characters from position 2 (included) to 5 (excluded)}
\PYG{g+go}{\PYGZsq{}tho\PYGZsq{}}
\end{Verbatim}

注意，包含起始的字符，不包含末尾的字符。这使得 \code{s{[}:i{]} + s{[}i:{]}} 永远等于 \code{s}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{+} \PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}Python\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{+} \PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}Python\PYGZsq{}}
\end{Verbatim}

切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小。:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c}{\PYGZsh{} character from the beginning to position 2 (excluded)}
\PYG{g+go}{\PYGZsq{}Py\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}  \PYG{c}{\PYGZsh{} characters from position 4 (included) to the end}
\PYG{g+go}{\PYGZsq{}on\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]} \PYG{c}{\PYGZsh{} characters from the second\PYGZhy{}last (included) to the end}
\PYG{g+go}{\PYGZsq{}on\PYGZsq{}}
\end{Verbatim}

有个办法可以很容易地记住切片的工作方式：切片时的索引是在两个字符 \emph{之间} 。左边第一个字符的索引为 0，而长度为 \emph{n}  的
字符串其最后一个字符的右界索引为 \emph{n}。例如:

\begin{Verbatim}[commandchars=\\\{\}]
 +\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
 \textbar{} P \textbar{} y \textbar{} t \textbar{} h \textbar{} o \textbar{} n \textbar{}
 +\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
 0   1   2   3   4   5   6
\PYGZhy{}6  \PYGZhy{}5  \PYGZhy{}4  \PYGZhy{}3  \PYGZhy{}2  \PYGZhy{}1
\end{Verbatim}

文本中的第一行数字给出字符串中的索引点 0...6。第二行给出相应的负索引。切片是 \emph{i} 到 \emph{j} 两个数值标示的边界之间的所有字符。

对于非负索引，如果上下都在边界内，切片长度就是两个索引之差。例如，\code{word{[}1:3{]}} 是 2 。

试图使用太大的索引会导致错误:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{42}\PYG{p}{]}  \PYG{c}{\PYGZsh{} the word only has 6 characters}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
\PYG{g+gr}{IndexError}: \PYG{n}{string index out of range}
\end{Verbatim}

Python 能够优雅地处理那些没有意义的切片索引：一个过大的索引值(即下标值大于字符串实际长度)将被字符串实际长度所代替，
当上边界比下边界大时(即切片左值大于右值)就返回空字符串:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{l+m+mi}{42}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}on\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{42}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{Verbatim}

Python字符串不可以被更改 --- 它们是 \href{https://docs.python.org/3/glossary.html\#term-immutable}{不可变的} 。因此，赋值给字符串索引的位置会导致错误:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{J}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{  ...}
\PYG{g+go}{TypeError: \PYGZsq{}str\PYGZsq{} object does not support item assignment}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{py}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{  ...}
\PYG{g+go}{TypeError: \PYGZsq{}str\PYGZsq{} object does not support item assignment}
\end{Verbatim}

如果你需要一个不同的字符串，你应该创建一个新的:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{J}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}Jython\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{word}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{py}\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{\PYGZsq{}Pypy\PYGZsq{}}
\end{Verbatim}

内置函数 \href{https://docs.python.org/3/library/functions.html\#len}{len()} 返回字符串长度:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{supercalifragilisticexpialidocious}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{34}
\end{Verbatim}


\strong{参见:}

\begin{description}
\item[{\href{https://docs.python.org/3/library/stdtypes.html\#textseq}{Text Sequence Type — str}}] \leavevmode
字符串是 \textbf{序列类型} 的例子，它们支持这种类型共同的操作。

\item[{\href{https://docs.python.org/3/library/stdtypes.html\#string-methods}{String Methods}}] \leavevmode
字符串和Unicode字符串都支持大量的方法用于基本的转换和查找。

\item[{\href{https://docs.python.org/3/library/string.html\#string-formatting}{String Formatting}}] \leavevmode
这里描述了使用 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 进行字符串格式化的信息。

\item[{\href{https://docs.python.org/3/library/stdtypes.html\#old-string-formatting}{String Formatting Operations}}] \leavevmode
这里关于老式的左操符 \code{\%} 格式化字符串和Unicode字符串的详细说明

\end{description}




\subsection{列表}
\label{introduction:tut-lists}\label{introduction:id6}
Python 有几个 \emph{复合} 数据类型，用于表示其它的值。最通用的是 \emph{list} (列表) ，
它可以看作中括号之间的一列逗号分隔的值。
列表的元素不必是同一类型:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares}
\PYG{g+go}{[1, 4, 9, 16, 25]}
\end{Verbatim}

就像字符串(以及其它所有内建的 \href{https://docs.python.org/3/glossary.html\#term-sequence}{序列} 类型)一样，列表可以被索引和切片:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}  \PYG{c}{\PYGZsh{} indexing returns the item}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}  \PYG{c}{\PYGZsh{} slicing returns a new list}
\PYG{g+go}{[9, 16, 25]}
\end{Verbatim}

所有的切片操作都会返回一个包含指定元素的新列表。这意味着下面的切片操作会返回列表的一个新的（浅）拷贝副本:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{g+go}{[1, 4, 9, 16, 25]}
\end{Verbatim}

列表也支持连接这样的操作:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{81}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}
\PYG{g+go}{[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]}
\end{Verbatim}

不像 \emph{不可变的} 字符串，列表是 \emph{可变的}，它允许修改元素:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cubes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{65}\PYG{p}{,} \PYG{l+m+mi}{125}\PYG{p}{]}  \PYG{c}{\PYGZsh{} something\PYGZsq{}s wrong here}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{4} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}  \PYG{c}{\PYGZsh{} the cube of 4 is 64, not 65!}
\PYG{g+go}{64}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cubes}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{64}  \PYG{c}{\PYGZsh{} replace the wrong value}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cubes}
\PYG{g+go}{[1, 8, 27, 64, 125]}
\end{Verbatim}

你还可以使用 \code{append()} \emph{方法} （后面我们会看到更多关于列表的方法的内容）在列表的末尾添加新的元素:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cubes}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{216}\PYG{p}{)}  \PYG{c}{\PYGZsh{} add the cube of 6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cubes}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{7} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)}  \PYG{c}{\PYGZsh{} and the cube of 7}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cubes}
\PYG{g+go}{[1, 8, 27, 64, 125, 216, 343]}
\end{Verbatim}

也可以对切片赋值，此操作可以改变列表的尺寸，或清空列表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{d}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{e}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{f}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{g}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}f\PYGZsq{}, \PYGZsq{}g\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} replace some values}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}C\PYGZsq{}, \PYGZsq{}D\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}f\PYGZsq{}, \PYGZsq{}g\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} now remove them}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}f\PYGZsq{}, \PYGZsq{}g\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} clear the list by replacing all the elements with an empty list}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters}
\PYG{g+go}{[]}
\end{Verbatim}

内置函数 \href{https://docs.python.org/3/library/functions.html\#len}{len()} 同样适用于列表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{letters} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{d}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{letters}\PYG{p}{)}
\PYG{g+go}{4}
\end{Verbatim}

允许嵌套列表(创建一个包含其它列表的列表)，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{n} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{n}{n}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}
\PYG{g+go}{[[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}], [1, 2, 3]]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{[\PYGZsq{}a\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+go}{\PYGZsq{}b\PYGZsq{}}
\end{Verbatim}


\section{编程的第一步}
\label{introduction:tut-firststeps}\label{introduction:id7}
当然，我们可以使用 Python 完成比二加二更复杂的任务。例如，我们可以写一个生成 \emph{菲波那契} 子序列的程序，如下所示:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Fibonacci series:}
\PYG{g+gp}{... }\PYG{c}{\PYGZsh{} the sum of two elements defines the next}
\PYG{g+gp}{... }\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{g+gp}{...}
\PYG{g+go}{1}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{5}
\PYG{g+go}{8}
\end{Verbatim}

这个例子介绍了几个新功能。
\begin{itemize}
\item {} 
第一行包括了一个 \emph{多重赋值}：变量 \code{a} 和 \code{b} 同时获得了新的值 0 和 1 ，最后一行又使用了一次。
在这个演示中，变量赋值前，右边首先完成计算。右边的表达式从左到右计算。

\item {} 
条件（这里是 \code{b \textless{} 10} ）为 true 时， \href{https://docs.python.org/3/reference/compound\_stmts.html\#while}{while} 循环执行。在 Python 中，类似于 C，任何非零整数都是 true；
0 是 false ，条件也可以是字符串或列表，实际上可以是任何序列；所有长度不为零的序列是 true，空序列是 false。
示例中是一个简单的比较。标准比较操作符与 C 相同： \code{\textless{}} ， \code{\textgreater{}} ， \code{==} ， \code{\textless{}=}， \code{\textgreater{}=} 和 \code{!=}。

\item {} 
循环体是 \emph{缩进} 的：缩进是 Python 组织语句的方法。Python (还)不提供集成的行编辑功能，所以你要为每一个
缩进行输入 TAB 或空格。实践中建议你找个文本编辑来录入复杂的 Python 程序，大多数文本编辑器提供自动缩进。
交互式录入复合语句时，必须在最后输入一个空行来标识结束（因为解释器没办法猜测你输入的哪一行是最后一行），
需要注意的是同一个语句块中的语句块必须缩进同样数量的空白。

\item {} 
关键字 \href{https://docs.python.org/3/library/functions.html\#print}{print()} 语句输出给定表达式的值。它控制多个表达式和字符串输出为你想要的字符串（就像我们在前面计算器的例子中那样）。
字符串打印时不用引号包围，每两个子项之间插入空间，所以你可以把格式弄得很漂亮，像这样:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{256}\PYG{o}{*}\PYG{l+m+mi}{256}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of i is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
\PYG{g+go}{The value of i is 65536}
\end{Verbatim}

用一个逗号结尾就可以禁止输出换行，或者在输出的结尾跟不同的字符串:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1000}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{g+gp}{...}
\PYG{g+go}{1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,}
\end{Verbatim}

\end{itemize}


\chapter{深入 Python 流程控制}
\label{controlflow:while}\label{controlflow:python}\label{controlflow:tut-morecontrol}\label{controlflow::doc}
除了前面介绍的 \href{https://docs.python.org/3/reference/compound\_stmts.html\#while}{while} 语句，Python 还从其它语言借鉴了一些流程控制语句，并有所改变。


\section{if 语句}
\label{controlflow:tut-if}\label{controlflow:if}
也许最有名的是 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 语句。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Please enter an integer: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Please enter an integer: 42}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{g+gp}{... }     \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{g+gp}{... }     \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Negative changed to zero}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{elif} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{g+gp}{... }     \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Zero}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{elif} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{g+gp}{... }     \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Single}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{else}\PYG{p}{:}
\PYG{g+gp}{... }     \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{More}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{More}
\end{Verbatim}

可能会有零到多个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#elif}{elif} ，和一个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#else}{else} ，它们是可选的。关键字 ` \href{https://docs.python.org/3/reference/compound\_stmts.html\#elif}{elif} ` 是 \emph{else if} 的缩写，
这个可以有效地避免过深的缩进。\href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} ... \href{https://docs.python.org/3/reference/compound\_stmts.html\#elif}{elif} ... \href{https://docs.python.org/3/reference/compound\_stmts.html\#elif}{elif} ... 序列用于替代其它语言中的 \code{switch} 或 \code{case} 语句。


\section{for 语句}
\label{controlflow:tut-for}\label{controlflow:for}
\index{语句!for}\index{for!语句}
Python 中的 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 语句和 C 或 Pascal 中的略有不同。通常的循环可能会依据一个等差数值步进过程（如 Pascal），
或由用户来定义迭代步骤和中止条件（如 C ），Python 的 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for}  语句依据任意序列（链表或字符串）中的子项，
按它们在序列中的顺序来进行迭代。例如（这里并没有要混淆视听）：

\begin{notice}{note}{注解:}
这里有人建议给出一个真实的 C 语言例子，但是这样仅仅对那些会 C 的人有效果而对不会 C 的人将造成困扰
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Measure some strings:}
\PYG{g+gp}{... }\PYG{n}{words} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{window}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{defenestrate}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{cat 3}
\PYG{g+go}{window 6}
\PYG{g+go}{defenestrate 12}
\end{Verbatim}

在迭代过程中修改迭代序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。
如果你想要修改你迭代的序列（例如，复制选择项），你可以迭代它的复本。使用切片就可以很方便的做到这一点:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{:}  \PYG{c}{\PYGZsh{} Loop over a slice copy of the entire list.}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{6}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{words}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{words}
\PYG{g+go}{[\PYGZsq{}defenestrate\PYGZsq{}, \PYGZsq{}cat\PYGZsq{}, \PYGZsq{}window\PYGZsq{}, \PYGZsq{}defenestrate\PYGZsq{}]}
\end{Verbatim}


\section{range() 函数}
\label{controlflow:tut-range}\label{controlflow:range}
如果你需要一个数值序列，内置函数 \href{https://docs.python.org/3/library/stdtypes.html\#range}{range()} 会很方便，它生成一个等差级的数链表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{4}
\end{Verbatim}

\code{range(10)} 生成了一个包含 10 个值的链表，它用链表的索引值填充了这个长度为 10 的列表，
所生成的链表中，不包括范围中的结束值。也可以让 \href{https://docs.python.org/3/library/stdtypes.html\#range}{range()} 操作从另一个数值开始，或者可以指定一个不同的步进值
（甚至是负数，有时这也被称为 “步长”）:

\begin{Verbatim}[commandchars=\\\{\}]
range(5, 10)
   5 through 9

range(0, 10, 3)
   0, 3, 6, 9

range(\PYGZhy{}10, \PYGZhy{}100, \PYGZhy{}30)
  \PYGZhy{}10, \PYGZhy{}40, \PYGZhy{}70
\end{Verbatim}

需要通过索引迭代链表的话，可以结合使用 \href{https://docs.python.org/3/library/stdtypes.html\#range}{range()} 和 \href{https://docs.python.org/3/library/functions.html\#len}{len()}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{had}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{little}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lamb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{0 Mary}
\PYG{g+go}{1 had}
\PYG{g+go}{2 a}
\PYG{g+go}{3 little}
\PYG{g+go}{4 lamb}
\end{Verbatim}

不过，这种场合可以使用更方便的 \href{https://docs.python.org/3/library/functions.html\#enumerate}{enumerate()}，请参见 {\hyperref[datastructures:tut-loopidioms]{\emph{\DUspan{}{循环技巧}}}} (\autopageref*{datastructures:tut-loopidioms})。

如果你只是打印一个序列的话会发生奇怪的事情:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{range(0, 10)}
\end{Verbatim}

在表面上看 \href{https://docs.python.org/3/library/stdtypes.html\#range}{range()} 函数返回的对象表现为它是一个列表，但事实上它并不是。它是一个对象，一个当你迭代它时，
它能够返回一个包含你所期望的连续值的序列；但为了节省空间，它并不真正构造列表。

我们称此类对象是 \emph{可迭代的}，它适合作为函数或结构体的一个目标，然后期望从这个目标中获得连续项直到结束。
我们已经见过的 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 语句，它就是这样一个迭代器。\href{https://docs.python.org/3/library/stdtypes.html\#list}{list()} 函数是另外一个（ \emph{迭代器} ），它从可迭代（对象）中创建列表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[0, 1, 2, 3, 4]}
\end{Verbatim}

稍后我们会看到更多返回可迭代（对象）和以可迭代（对象）作为参数的函数。


\section{break 和 continue 语句, 以及循环中的 else 子句}
\label{controlflow:break-continue-else}\label{controlflow:tut-break}
\href{https://docs.python.org/3/reference/simple\_stmts.html\#break}{break} 语句和 C 中的类似，用于跳出最近的一级 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 或 \href{https://docs.python.org/3/reference/compound\_stmts.html\#while}{while} 循环。

循环可以有一个 \code{else} 分句；它在循环迭代完整个列表（对于 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} ）或执行条件为 false （对于 \href{https://docs.python.org/3/reference/compound\_stmts.html\#while}{while} ）时执行，
但循环被 \href{https://docs.python.org/3/reference/simple\_stmts.html\#break}{break} 中止的情况下不会执行。以下搜索素数的示例程序演示了这个分句:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{k}{print}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{equals}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{o}{/}\PYG{o}{/}\PYG{n}{x}\PYG{p}{)}
\PYG{g+gp}{... }            \PYG{k}{break}
\PYG{g+gp}{... }    \PYG{k}{else}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{c}{\PYGZsh{} loop fell through without finding a factor}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is a prime number}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{2 is a prime number}
\PYG{g+go}{3 is a prime number}
\PYG{g+go}{4 equals 2 * 2}
\PYG{g+go}{5 is a prime number}
\PYG{g+go}{6 equals 2 * 3}
\PYG{g+go}{7 is a prime number}
\PYG{g+go}{8 equals 2 * 4}
\PYG{g+go}{9 equals 3 * 3}
\end{Verbatim}

(Yes, 这是正确的代码。看仔细：\code{else} 语句是属于 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 循环之中的， \textbf{不是}  \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 语句。)

\code{else} 子句与循环一起使用时与 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句的 \code{else} 子句类似，而有别于 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 语句。 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句
的 \code{else} 子句在未出现异常时运行，循环的 \code{else} 子句在未出现 \code{break} 时运行。
更多关于 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句和异常的内容，请参见 {\hyperref[errors:tut-handling]{\emph{\DUspan{}{异常处理}}}} (\autopageref*{errors:tut-handling})。

\href{https://docs.python.org/3/reference/simple\_stmts.html\#continue}{continue} 语句是从 C 中借鉴来的，它表示循环继续执行下一次迭代:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{num} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Found an even number}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{num}\PYG{p}{)}
\PYG{g+gp}{... }        \PYG{k}{continue}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Found a number}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{num}\PYG{p}{)}
\PYG{g+go}{Found an even number 2}
\PYG{g+go}{Found a number 3}
\PYG{g+go}{Found an even number 4}
\PYG{g+go}{Found a number 5}
\PYG{g+go}{Found an even number 6}
\PYG{g+go}{Found a number 7}
\PYG{g+go}{Found an even number 8}
\PYG{g+go}{Found a number 9}
\end{Verbatim}


\section{pass 语句}
\label{controlflow:tut-pass}\label{controlflow:pass}
\href{https://docs.python.org/3/reference/simple\_stmts.html\#pass}{pass} 语句什么也不做。它用于那些语法上必须要有某个语句，但程序什么也不做的场合，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{pass}  \PYG{c}{\PYGZsh{} Busy\PYGZhy{}wait for keyboard interrupt (Ctrl+C)}
\PYG{g+gp}{...}
\end{Verbatim}

这通常用于创建最小结构的类:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{MyEmptyClass}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{pass}
\PYG{g+gp}{...}
\end{Verbatim}

另一方面，\href{https://docs.python.org/3/reference/simple\_stmts.html\#pass}{pass} 可以在创建新代码时用来做函数或控制体的占位符。
也可以看作是一个抽象的级别的方法。\href{https://docs.python.org/3/reference/simple\_stmts.html\#pass}{pass} 会被悄悄的忽略:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{initlog}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{pass}   \PYG{c}{\PYGZsh{} Remember to implement this!}
\PYG{g+gp}{...}
\end{Verbatim}


\section{定义函数}
\label{controlflow:tut-functions}\label{controlflow:id1}
我们可以创建一个用来生成指定边界的斐波那契数列的函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{fib}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}    \PYG{c}{\PYGZsh{} write Fibonacci series up to n}
\PYG{g+gp}{... }    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Print a Fibonacci series up to n.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{g+gp}{... }    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
\PYG{g+gp}{... }    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Now call the function we just defined:}
\PYG{g+gp}{... }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{2000}\PYG{p}{)}
\PYG{g+go}{0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597}
\end{Verbatim}

\index{documentation strings}\index{docstrings}\index{strings, documentation}
关键字 \href{https://docs.python.org/3/reference/compound\_stmts.html\#def}{def} 引入了一个函数 \emph{定义}。在其后必须跟有函数名和包括形式参数的圆括号。函数体语句从下一行开始，必须是缩进的。

函数体的第一行语句可以是可选的字符串文本，这个字符串是函数的文档字符串，或者称为 \emph{docstring}。
（更多关于 docstrings 的信息请参考 {\hyperref[controlflow:tut-docstrings]{\emph{\DUspan{}{文档字符串}}}} (\autopageref*{controlflow:tut-docstrings})） 有些工具通过 docstrings 自动生成在线的或可打印的文档，
或者让用户通过代码交互浏览；在你的代码中包含 docstrings 是一个好的实践，让它成为习惯吧。

函数 \emph{调用} 会为函数局部变量生成一个新的符号表。确切的说，所有函数中的变量赋值都是将值存储在局部符号表。
变量引用首先在局部符号表中查找，然后是包含函数的局部符号表，接着是全局符号表，最后是内置名字表。
因此，全局变量不能在函数中直接赋值（除非用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 语句命名），尽管他们可以被引用。

函数引用的实际参数在函数调用时引入局部符号表，因此，实参总是 \emph{传值调用} （这里的 \emph{值} 总是一个对象引用 ，而不是该对象的值）
。\footnote{
实际上， \emph{引用对象调用} 描述的更为准确。如果传入一个可变对像，调用者会看到调用操作带来的任何变化（如子项插入到列表中）。
}  一个函数被另一个函数调用时，一个新的局部符号表在调用过程中被创建。

一个函数定义会在当前符号表内引入函数名。函数名所代表的函数被解释器认为是一种类型，我们叫它 \emph{用户自定义函数} 。
这个值可以赋予其他的名字（即变量名），然后它也可以被当做函数使用。这可以作为通用的重命名机制:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib}
\PYG{g+go}{\PYGZlt{}function fib at 10042ed0\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{fib}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0 1 1 2 3 5 8 13 21 34 55 89}
\end{Verbatim}

如果你使用过其他语言，你可能会反对说：\code{fib} 不是一个函数，而是一个方法，因为它并不返回任何值。
实际上，没有 \href{https://docs.python.org/3/reference/simple\_stmts.html\#return}{return} 语句的函数确实会返回一个值，虽然是一个相当令人厌烦的值。
这个值被称为 \code{None} （这是一个内建名称）。如果 \code{None} 值是唯一被书写的值，那么在写的时候通常会被解释器忽略。
如果你确实想看到这个值的输出内容，请使用 \href{https://docs.python.org/3/library/functions.html\#print}{print()} 函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{None}
\end{Verbatim}

定义一个返回斐波那契数列数字列表的函数，而不是打印它，是很简单的:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{fib2}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:} \PYG{c}{\PYGZsh{} return Fibonacci series up to n}
\PYG{g+gp}{... }    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return a list containing the Fibonacci series up to n.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{g+gp}{... }    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
\PYG{g+gp}{... }    \PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{result}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}    \PYG{c}{\PYGZsh{} see below}
\PYG{g+gp}{... }        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{result}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f100} \PYG{o}{=} \PYG{n}{fib2}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}    \PYG{c}{\PYGZsh{} call it}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f100}                \PYG{c}{\PYGZsh{} write the result}
\PYG{g+go}{[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]}
\end{Verbatim}

和以前一样，这个例子演示了一些新的 Python 功能：
\begin{itemize}
\item {} 
\href{https://docs.python.org/3/reference/simple\_stmts.html\#return}{return} 语句从函数中返回一个值。不带表达式的 \href{https://docs.python.org/3/reference/simple\_stmts.html\#return}{return} 返回 \code{None}。
过程结束后也会返回 \code{None}。

\item {} 
语句 \code{result.append(b)} 称为链表对象 \code{result} 的一个 \emph{方法}。方法是一个“属于”某个对象的函数，
它被命名为 \code{obj.methodename}，这里的 \code{obj} 是某个对象（可能是一个表达式）， \code{methodname} 是某个
在该对象类型中定义的方法命名。不同的类型定义不同的方法。不同类型可能有同样名字的方法，但不会混淆。
（当你定义自己的对象类型和方法时，可能会出现这种情况，\emph{class} 的定义方法详见 {\hyperref[classes:tut-classes]{\emph{\DUspan{}{类}}}} (\autopageref*{classes:tut-classes}) ）。
示例中演示的 \code{append()} 方法由链表对象定义，它向链表中加入一个新元素。
在示例中它等同于 \code{result = result + {[}a{]}}，不过效率更高。

\end{itemize}


\section{深入 Python 函数定义}
\label{controlflow:tut-defining}\label{controlflow:id3}
在 Python 中，你也可以定义包含若干参数的函数。这里有三种可用的形式，也可以混合使用。


\subsection{默认参数值}
\label{controlflow:id4}\label{controlflow:tut-defaultargs}
最常用的一种形式是为一个或多个参数指定默认值。这会创建一个比定义时允许使用更少的参数的可调用函数。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ask\PYGZus{}ok}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{,} \PYG{n}{retries}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{complaint}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yes or no, please!}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
        \PYG{n}{ok} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{ok} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ye}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yes}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{True}
        \PYG{k}{if} \PYG{n}{ok} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{no}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{False}
        \PYG{n}{retries} \PYG{o}{=} \PYG{n}{retries} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{retries} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{OSError}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{uncooperative user}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{complaint}\PYG{p}{)}
\end{Verbatim}

这个函数可以通过几种不同的方式调用:
\begin{itemize}
\item {} 
只给出必要的参数:

\code{ask\_ok('Do you really want to quit?')}

\item {} 
给出一个可选的参数:

\code{ask\_ok('OK to overwrite the file?', 2)}

\item {} 
或者给出所有的参数:

\code{ask\_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')}

\end{itemize}

这个例子还介绍了 \href{https://docs.python.org/3/reference/expressions.html\#in}{in} 关键字。它检测序列中是否包含某个确定的值。

默认值在函数 \emph{定义} 作用域时被赋值，如下所示:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{arg}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

将会输出 \code{5}。

\textbf{重要警告:}  默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。
例如，下面的函数在后续调用过程中会累积传给它的参数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{L}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{L}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

这将输出:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{L}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{L} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{L}
\end{Verbatim}


\subsection{关键字参数}
\label{controlflow:id5}\label{controlflow:tut-keywordargs}
函数可以通过 关键字参数 的形式来调用，形如 \code{keyword = value}。例如，以下的函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{parrot}\PYG{p}{(}\PYG{n}{voltage}\PYG{p}{,} \PYG{n}{state}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a stiff}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{action}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{voom}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Norwegian Blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} This parrot wouldn}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{action}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{if you put}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{voltage}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{volts through it.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} Lovely plumage, the}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} It}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{state}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

接受一个必要参数 (\code{voltage}) 以及三个可选参数
(\code{state}, \code{action}, 和 \code{type})。可以用以下的任一方法调用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{parrot}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}                                          \PYG{c}{\PYGZsh{} 1 positional argument}
\PYG{n}{parrot}\PYG{p}{(}\PYG{n}{voltage}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}                                  \PYG{c}{\PYGZsh{} 1 keyword argument}
\PYG{n}{parrot}\PYG{p}{(}\PYG{n}{voltage}\PYG{o}{=}\PYG{l+m+mi}{1000000}\PYG{p}{,} \PYG{n}{action}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VOOOOOM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}             \PYG{c}{\PYGZsh{} 2 keyword arguments}
\PYG{n}{parrot}\PYG{p}{(}\PYG{n}{action}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VOOOOOM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{voltage}\PYG{o}{=}\PYG{l+m+mi}{1000000}\PYG{p}{)}             \PYG{c}{\PYGZsh{} 2 keyword arguments}
\PYG{n}{parrot}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a million}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bereft of life}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jump}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}         \PYG{c}{\PYGZsh{} 3 positional arguments}
\PYG{n}{parrot}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a thousand}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{state}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pushing up the daisies}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} 1 positional, 1 keyword}
\end{Verbatim}

不过以下几种调用是无效的:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{parrot}\PYG{p}{(}\PYG{p}{)}                     \PYG{c}{\PYGZsh{} required argument missing}
\PYG{n}{parrot}\PYG{p}{(}\PYG{n}{voltage}\PYG{o}{=}\PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dead}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} non\PYGZhy{}keyword argument after a keyword argument}
\PYG{n}{parrot}\PYG{p}{(}\PYG{l+m+mi}{110}\PYG{p}{,} \PYG{n}{voltage}\PYG{o}{=}\PYG{l+m+mi}{220}\PYG{p}{)}     \PYG{c}{\PYGZsh{} duplicate value for the same argument}
\PYG{n}{parrot}\PYG{p}{(}\PYG{n}{actor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{John Cleese}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} unknown keyword argument}
\end{Verbatim}

在函数调用中，关键字的参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的某个参数相匹配
（例如 \code{actor} 不是 \code{parrot} 函数的有效参数），它们的顺序并不重要。
这也包括非可选参数（例如 \code{parrot(voltage=1000)} 也是有效的）。任何参数都不可以多次赋值。下面的示例由于这种限制将失败:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{function}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{pass}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{function}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{TypeError}: \PYG{n}{function() got multiple values for keyword argument \PYGZsq{}a\PYGZsq{}}
\end{Verbatim}

引入一个形如 \code{**name} 的参数时，它接收一个字典（参见 \href{https://docs.python.org/3/library/stdtypes.html\#typesmapping}{Mapping Types — dict} ），
该字典包含了所有未出现在形式参数列表中的关键字参数。这里可能还会组合使用一个形如 \code{*name} （下一小节详细介绍） 的形式参数，
它接收一个元组，包含了所有没有出现在形式参数列表中的参数值（ \code{*name} 必须在 \code{**name} 之前出现）。
例如，我们这样定义一个函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cheeseshop}\PYG{p}{(}\PYG{n}{kind}\PYG{p}{,} \PYG{o}{*}\PYG{n}{arguments}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{keywords}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} Do you have any}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kind}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} I}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{m sorry, we}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{re all out of}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{kind}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{arg} \PYG{o+ow}{in} \PYG{n}{arguments}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{*} \PYG{l+m+mi}{40}\PYG{p}{)}
    \PYG{n}{keys} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{keywords}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{kw} \PYG{o+ow}{in} \PYG{n}{keys}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{kw}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{keywords}\PYG{p}{[}\PYG{n}{kw}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

它可以像这样调用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cheeseshop}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Limburger}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s very runny, sir.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
           \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s really very, VERY runny, sir.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
           \PYG{n}{shopkeeper}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Michael Palin}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
           \PYG{n}{client}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{John Cleese}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
           \PYG{n}{sketch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cheese Shop Sketch}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

并且它必然将输出:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{} Do you have any Limburger ?
\PYGZhy{}\PYGZhy{} I\PYGZsq{}m sorry, we\PYGZsq{}re all out of Limburger
It\PYGZsq{}s very runny, sir.
It\PYGZsq{}s really very, VERY runny, sir.
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
client : John Cleese
shopkeeper : Michael Palin
sketch : Cheese Shop Sketch
\end{Verbatim}

注意在打印关键字参数之前，通过对关键字字典 \code{keys()} 方法的结果进行排序，
生成了关键字参数名的列表；如果不这样做，打印出来的参数的顺序是未定义的。


\subsection{可变参数列表}
\label{controlflow:id7}\label{controlflow:tut-arbitraryargs}
\index{语句!*}\index{*!语句}
最后，一个最不常用的选择是可以让函数调用可变个数的参数。
这些参数被包装进一个元组（参见 {\hyperref[datastructures:tut-tuples]{\emph{\DUspan{}{元组和序列}}}} (\autopageref*{datastructures:tut-tuples}) ）。在这些可变个数的参数之前，可以有零到多个普通的参数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{write\PYGZus{}multiple\PYGZus{}items}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,} \PYG{n}{separator}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{separator}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

通常，这些 \code{可变} 参数是参数列表中的最后一个，因为它们将把所有的剩余输入参数传递给函数。
任何出现在 \code{*args} 后的参数是关键字参数，这意味着，他们只能被用作关键字，而不是位置参数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{concat}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{k}{return} \PYG{n}{sep}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{concat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{earth}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{venus}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}earth/mars/venus\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{concat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{earth}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mars}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{venus}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sep}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}earth.mars.venus\PYGZsq{}}
\end{Verbatim}


\subsection{参数列表的分拆}
\label{controlflow:id8}\label{controlflow:tut-unpacking-arguments}
另有一种相反的情况: 当你要传递的参数已经是一个列表，但要调用的函数却接受分开的一个个的参数值。
这时候你要把已有的列表拆开来。例如内建函数 \href{https://docs.python.org/3/library/stdtypes.html\#range}{range()} 需要要独立的 \emph{start}，\emph{stop} 参数。
你可以在调用函数时加一个 \code{*} 操作符来自动把参数列表拆开:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}            \PYG{c}{\PYGZsh{} normal call with separate arguments}
\PYG{g+go}{[3, 4, 5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{args} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{)}            \PYG{c}{\PYGZsh{} call with arguments unpacked from a list}
\PYG{g+go}{[3, 4, 5]}
\end{Verbatim}

\index{语句!**}\index{**!语句}
以同样的方式，可以使用 \code{**} 操作符分拆关键字参数为字典:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{parrot}\PYG{p}{(}\PYG{n}{voltage}\PYG{p}{,} \PYG{n}{state}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a stiff}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{action}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{voom}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} This parrot wouldn}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{action}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{if you put}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{voltage}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{volts through it.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{E}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{state}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{voltage}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{four million}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{state}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bleedin}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ demised}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{action}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{VOOM}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parrot}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{d}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}\PYGZhy{} This parrot wouldn\PYGZsq{}t VOOM if you put four million volts through it. E\PYGZsq{}s bleedin\PYGZsq{} demised !}
\end{Verbatim}


\subsection{Lambda 形式}
\label{controlflow:tut-lambda}\label{controlflow:lambda}
出于实际需要，有几种通常在函数式编程语言例如 Lisp 中出现的功能加入到了 Python。
通过 \href{https://docs.python.org/3/reference/expressions.html\#lambda}{lambda}  关键字，可以创建短小的匿名函数。下面是一个匿名函数它返回两个参数的和： \code{lambda a, b: a+b}。
Lambda 形式可以用于任何需要的函数对象。出于语法限制，它们只能有一个单独的表达式。
语义上讲，它们只是普通函数定义中的一个语法技巧。类似于嵌套函数定义，lambda 形式可以从外部作用域引用变量:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{make\PYGZus{}incrementor}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o}{+} \PYG{n}{n}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{make\PYGZus{}incrementor}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{42}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{43}
\end{Verbatim}

上面的示例使用 lambda 表达式返回一个函数。另一个用途是将一个小函数作为参数传递:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pairs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{four}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pairs}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{pair}\PYG{p}{:} \PYG{n}{pair}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pairs}
\PYG{g+go}{[(4, \PYGZsq{}four\PYGZsq{}), (1, \PYGZsq{}one\PYGZsq{}), (3, \PYGZsq{}three\PYGZsq{}), (2, \PYGZsq{}two\PYGZsq{})]}
\end{Verbatim}


\subsection{文档字符串}
\label{controlflow:tut-docstrings}\label{controlflow:id9}
\index{docstrings}\index{documentation strings}\index{strings, documentation}
这里将介绍文档字符串的概念和格式。

第一行应该是关于对象用途的简介。简短起见，不用明确的陈述对象名或类型，因为它们可以从别的途径了解到
（除非这个名字碰巧就是描述这个函数操作的动词）。这一行应该以大写字母开头，以句号结尾。

如果文档字符串有多行，第二行应该空出来，与接下来的详细描述明确分隔。
接下来的文档应该有一或多段描述对象的调用约定、边界效应等。

Python 的解释器不会从多行的文档字符串中去除缩进，所以必要的时候应当自己清除缩进。
这符合通常的习惯。第一行之后的第一个非空行决定了整个文档的缩进格式。
（我们不用第一行是因为它通常紧靠着起始的引号，缩进格式显示的不清楚。）
留白“相当于”是字符串的起始缩进。每一行都不应该有缩进，如果有缩进的话，所有的留白都应该清除掉。
留白的长度应当等于扩展制表符的宽度（通常是8个空格）。

以下是一个多行文档字符串的示例:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Do nothing, but document it.}
\PYG{g+gp}{...}
\PYG{g+gp}{... }\PYG{l+s+sd}{    No, really, it doesn\PYGZsq{}t do anything.}
\PYG{g+gp}{... }\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{g+gp}{... }    \PYG{k}{pass}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{my\PYGZus{}function}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}}\PYG{p}{)}
\PYG{g+go}{Do nothing, but document it.}

\PYG{g+go}{    No, really, it doesn\PYGZsq{}t do anything.}
\end{Verbatim}


\subsection{函数注解}
\label{controlflow:id10}\label{controlflow:tut-annotations}
\index{function!annotations}\index{annotations!function}\index{-\textgreater{} (return annotation assignment)}
在用户自定义函数中 \href{https://docs.python.org/3/reference/compound\_stmts.html\#function}{注解} 是用来表示数据类型的一个可选的元数据信息。（详细信息请查看 \href{https://www.python.org/dev/peps/pep-0484}{PEP 484} ）。

注解存储在函数的一个 \emph{\_\_annotations\_\_} 属性当中， 参数的注解是跟在参数名字的冒号后面，
参数的赋值表达式则跟在注解的后面。 返回的注解是 \code{-\textgreater{}} 所指表达式，
它在函数参数列表和定义函数语句的冒号之间， 下面的例子包含了一个位置参数和一个关键字参数，以及一个返回值注解:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{ham}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{,} \PYG{n}{eggs}\PYG{p}{:} \PYG{n+nb}{str} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eggs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Annotations:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{f}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}annotations\PYGZus{}\PYGZus{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Arguments:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ham}\PYG{p}{,} \PYG{n}{eggs}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{ham} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ and }\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{eggs}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{Annotations: \PYGZob{}\PYGZsq{}ham\PYGZsq{}: \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}, \PYGZsq{}return\PYGZsq{}: \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}, \PYGZsq{}eggs\PYGZsq{}: \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}\PYGZcb{}}
\PYG{g+go}{Arguments: spam eggs}
\PYG{g+go}{\PYGZsq{}spam and eggs\PYGZsq{}}
\end{Verbatim}


\section{插曲：编码风格}
\label{controlflow:id11}\label{controlflow:tut-codingstyle}
\index{coding!style}\index{style!coding}
此时你已经可以写一些更长更复杂的 Python 程序了，是时候讨论一下 \emph{编码风格} 了。
大多数语言可以写（或者更明白的说， \emph{格式化} ）作几种不同的风格。有些比其它的更好读。
让你的代码对别人更易读是个好的做法，养成良好的编码风格对此很有帮助。

Python，\href{https://www.python.org/dev/peps/pep-0008}{PEP 8} 引入了大多数项目遵循的风格指导。它给出了一个高度可读，视觉友好的编码风格。
每个 Python 开发者都应该读一下，大多数要点都会对你有帮助：
\begin{itemize}
\item {} 
使用 4 空格缩进，而非 TAB
在小缩进（可以嵌套更深）和大缩进（更易读）之间，4空格是一个很好的折中。
TAB 会引发一些混乱，最好弃用

\item {} 
折行以确保其不会超过 79 个字符
这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件

\item {} 
使用空行分隔函数和类，以及函数中的大块代码

\item {} 
可能的话，注释独占一行

\item {} 
使用文档字符串

\item {} 
把空格放到操作符两边，以及逗号后面，但是括号里则不加空格：\code{a = f(1, 2) + g(3, 4)}

\item {} 
统一函数和类命名
推荐类名用 \code{驼峰命名}， 函数和方法名用 \code{小写和下划线}。总是用 \code{self} 作为方法的第一个参数
（关于类和方法的知识详见 {\hyperref[classes:tut-firstclasses]{\emph{\DUspan{}{初识类}}}} (\autopageref*{classes:tut-firstclasses}) ）

\item {} 
不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python 的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好

\item {} 
同样，也不要使用非 ASCII 字符作为标识符，除非是极少一部分不同语种的人会阅读或者维护这个代码。

\end{itemize}


\chapter{数据结构}
\label{datastructures:tut-structures}\label{datastructures:pep-484}\label{datastructures:id1}\label{datastructures::doc}
本章详细讨论了你已经学过的一些知识，同样也添加了一些的新内容。


\section{关于列表的更多内容}
\label{datastructures:tut-morelists}\label{datastructures:id2}
Python 的列表数据类型包含其他的一些方法。下面是所有的列表对象方法：


\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{append}}{\emph{x}}{}
把一个元素添加到链表的结尾，相当于 \code{a{[}len(a):{]} = {[}x{]}}。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{extend}}{\emph{L}}{}
将一个给定列表中的所有元素都添加到另一个列表中，相当于 \code{a{[}len(a):{]} = L}。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{insert}}{\emph{i}, \emph{x}}{}
在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，
例如 \code{a.insert(0, x)} 会插入到整个链表之前，而 \code{a.insert(len(a), x)} 相当于 \code{a.append(x)}。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{remove}}{\emph{x}}{}
删除链表中值为 \emph{x} 的第一个元素。如果没有这样的元素，会产生一个错误。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{pop}}{\optional{\emph{i}}}{}
从链表的指定位置删除元素，并将其返回。如果没有指定索引，\code{a.pop()} 返回最后一个元素。
元素随即从链表中被删除（方法中 \emph{i} 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，
你会经常在Python 库参考手册中遇到这样的标记）。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{clear}}{}{}
从列表中删除所有元素。相当于 \code{del a{[}:{]}}。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{index}}{\emph{x}}{}
返回链表中第一个值为 \emph{x} 的元素的索引。如果没有匹配的元素就会返回一个错误。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{count}}{\emph{x}}{}
返回 \emph{x} 在链表中出现的次数。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{sort}}{}{}
对链表中的元素就地进行排序。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{reverse}}{}{}
就地倒排链表中的元素。

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\code{list.}\bfcode{copy}}{}{}
返回列表的一个浅拷贝。等同于 \code{a{[}:{]}}。

\end{fulllineitems}


下面这个示例演示了链表的大部分方法:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{66.25}\PYG{p}{,} \PYG{l+m+mi}{333}\PYG{p}{,} \PYG{l+m+mi}{333}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1234.5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+m+mi}{333}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+m+mf}{66.25}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{2 1 0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{333}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[66.25, 333, \PYGZhy{}1, 333, 1, 1234.5, 333]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+m+mi}{333}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{333}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[66.25, \PYGZhy{}1, 333, 1, 1234.5, 333]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[333, 1234.5, 1, 333, \PYGZhy{}1, 66.25]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[\PYGZhy{}1, 1, 66.25, 333, 333, 1234.5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1234.5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[\PYGZhy{}1, 1, 66.25, 333, 333]}
\end{Verbatim}

也许大家会发现像 \code{insert}， \code{remove} 或者 \code{sort} 这些修改列表的方法没有打印返回值 --
它们返回 \code{None}。 \footnote{
别的语言可能会返回一个变化的对象，允许方法连续执行，像 \code{d-\textgreater{}insert("a")-\textgreater{}remove("b")-\textgreater{}sort();}。
}  在 python 中对所有可变的数据类型这是统一的设计原则。


\subsection{把链表当作堆栈使用}
\label{datastructures:id4}\label{datastructures:tut-lists-as-stacks}
链表方法使得链表可以很方便的做为一个堆栈来使用，堆栈的最先进入的元素会最后一个被释放（后进先出）。
用 \code{append()} 方法可以把一个元素添加到堆栈顶。用不指定索引的 \code{pop()} 方法可以把一个元素从堆栈顶释放出来。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}
\PYG{g+go}{[3, 4, 5, 6, 7]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{7}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}
\PYG{g+go}{[3, 4, 5, 6]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{stack}
\PYG{g+go}{[3, 4]}
\end{Verbatim}


\subsection{把链表当作队列使用}
\label{datastructures:id5}\label{datastructures:tut-lists-as-queues}
你也可以把链表当做队列使用，队列的最先进入的元素最先释放（先进先出）。不过，列表这样用效率不高。
相对来说从列表末尾添加和弹出很快；在头部插入和弹出很慢（因为，为了一个元素，要移动整个列表中的所有元素）。

要实现队列，使用 \href{https://docs.python.org/3/library/collections.html\#collections.deque}{collections.deque}，它为在首尾两端快速插入和删除而设计。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{deque}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{queue} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Eric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{John}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Michael}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{queue}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Terry}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}           \PYG{c}{\PYGZsh{} Terry arrives}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{queue}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Graham}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}          \PYG{c}{\PYGZsh{} Graham arrives}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{queue}\PYG{o}{.}\PYG{n}{popleft}\PYG{p}{(}\PYG{p}{)}                 \PYG{c}{\PYGZsh{} The first to arrive now leaves}
\PYG{g+go}{\PYGZsq{}Eric\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{queue}\PYG{o}{.}\PYG{n}{popleft}\PYG{p}{(}\PYG{p}{)}                 \PYG{c}{\PYGZsh{} The second to arrive now leaves}
\PYG{g+go}{\PYGZsq{}John\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{queue}                           \PYG{c}{\PYGZsh{} Remaining queue in order of arrival}
\PYG{g+go}{deque([\PYGZsq{}Michael\PYGZsq{}, \PYGZsq{}Terry\PYGZsq{}, \PYGZsq{}Graham\PYGZsq{}])}
\end{Verbatim}


\subsection{列表解析}
\label{datastructures:tut-listcomps}\label{datastructures:id6}
列表解析为从序列中创建列表提供了一个简单的方法。普通的应用程序通过将一些操作应用于序列的每个成员并通过返回的元素创建列表，
或者通过满足特定条件的元素创建子序列。

例如, 假设我们创建一个 squares 列表, 可以像下面方式:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{squares}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{squares}
\PYG{g+go}{[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]}
\end{Verbatim}

注意这个 for 循环中的被创建(或被重写)的名为 \code{x} 的变量在循环完毕后依然存在。
使用如下方法，我们可以计算squares的值而不会产生任何的副作用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

或者，等价于:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{squares} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\end{Verbatim}

上面这个方法更加简明且易读.

列表解析由包含一个表达式的括号组成，表达式后面跟随一个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 子句，
之后可以有零或多个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 或 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 子句。得到的结果是一个列表，这个列表由表达式依据其后面的 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 和 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 子句
上下文计算而来的结果构成。

例如，如下的列表解析结合两个列表中不相等的元素:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{k}{if} \PYG{n}{x} \PYG{o}{!=} \PYG{n}{y}\PYG{p}{]}
\PYG{g+go}{[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]}
\end{Verbatim}

等同于:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{combs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{if} \PYG{n}{x} \PYG{o}{!=} \PYG{n}{y}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{n}{combs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{combs}
\PYG{g+go}{[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]}
\end{Verbatim}

值得注意的是在上面两个方法中的 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 和 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 语句的顺序。

如果想要得到一个元组（例如，上面例子中的 \code{(x, y)}），必须要加上括号:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{vec} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} create a new list with the values doubled}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vec}\PYG{p}{]}
\PYG{g+go}{[\PYGZhy{}8, \PYGZhy{}4, 0, 4, 8]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} filter the list to exclude negative numbers}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vec} \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{[0, 2, 4]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} apply a function to all the elements}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vec}\PYG{p}{]}
\PYG{g+go}{[4, 2, 0, 2, 4]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} call a method on each element}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{freshfruit} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{  banana}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{  loganberry }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{passion fruit  }\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{weapon}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{weapon} \PYG{o+ow}{in} \PYG{n}{freshfruit}\PYG{p}{]}
\PYG{g+go}{[\PYGZsq{}banana\PYGZsq{}, \PYGZsq{}loganberry\PYGZsq{}, \PYGZsq{}passion fruit\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} create a list of 2\PYGZhy{}tuples like (number, square)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} the tuple must be parenthesized, otherwise an error is raised}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{  File \PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}, line 1, in ?}
\PYG{g+go}{    [x, x**2 for x in range(6)]}
\PYG{g+go}{               \PYGZca{}}
\PYG{g+go}{SyntaxError: invalid syntax}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} flatten a list using a listcomp with two \PYGZsq{}for\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{vec} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{num} \PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{vec} \PYG{k}{for} \PYG{n}{num} \PYG{o+ow}{in} \PYG{n}{elem}\PYG{p}{]}
\PYG{g+go}{[1, 2, 3, 4, 5, 6, 7, 8, 9]}
\end{Verbatim}

列表解析可使用复杂的表达式和嵌套函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[\PYGZsq{}3.1\PYGZsq{}, \PYGZsq{}3.14\PYGZsq{}, \PYGZsq{}3.142\PYGZsq{}, \PYGZsq{}3.1416\PYGZsq{}, \PYGZsq{}3.14159\PYGZsq{}]}
\end{Verbatim}


\subsection{嵌套的列表解析}
\label{datastructures:id7}
列表解析中的第一个表达式可以是任何表达式，包括列表解析。

考虑下面由三个长度为 4 的列表组成的 3x4 矩阵:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{matrix} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }    \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{]}
\end{Verbatim}

现在，如果你想交换行和列，可以用嵌套的列表解析:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{p}{[}\PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]}
\end{Verbatim}

像前面看到的，嵌套的列表解析是对 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 后面的内容进行求值，所以上例就等价于:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{transposed} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{transposed}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{transposed}
\PYG{g+go}{[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]}
\end{Verbatim}

反过来说，如下也是一样的:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{transposed} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{c}{\PYGZsh{} the following 3 lines implement the nested listcomp}
\PYG{g+gp}{... }    \PYG{n}{transposed\PYGZus{}row} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{... }    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{transposed\PYGZus{}row}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{row}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{transposed}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{transposed\PYGZus{}row}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{transposed}
\PYG{g+go}{[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]}
\end{Verbatim}

在实际中，你应该更喜欢使用内置函数组成的复杂流程语句。对此种情况 \href{https://docs.python.org/3/library/functions.html\#zip}{zip()} 函数将会做的更好:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]}
\end{Verbatim}

更多关于本行中使用的星号的说明，参考 {\hyperref[controlflow:tut-unpacking-arguments]{\emph{\DUspan{}{参数列表的分拆}}}} (\autopageref*{controlflow:tut-unpacking-arguments})。


\section{del 语句}
\label{datastructures:del}\label{datastructures:tut-del}
有个方法可以从列表中按给定的索引而不是值来删除一个子项： \href{https://docs.python.org/3/reference/simple\_stmts.html\#del}{del} 语句。
它不同于有返回值的 \code{pop()} 方法。语句 \href{https://docs.python.org/3/reference/simple\_stmts.html\#del}{del}  还可以从列表中删除切片或
清空整个列表（我们以前介绍过一个方法是将空列表赋值给列表的切片）。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{66.25}\PYG{p}{,} \PYG{l+m+mi}{333}\PYG{p}{,} \PYG{l+m+mi}{333}\PYG{p}{,} \PYG{l+m+mf}{1234.5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 66.25, 333, 333, 1234.5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[1, 66.25, 1234.5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{[]}
\end{Verbatim}

\href{https://docs.python.org/3/reference/simple\_stmts.html\#del}{del} 也可以删除整个变量:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}
\end{Verbatim}

此后再引用 \code{a} 会引发错误（直到另一个值赋给它为止）。我们在后面的内容中可以看到 \href{https://docs.python.org/3/reference/simple\_stmts.html\#del}{del} 的其它用法。


\section{元组和序列}
\label{datastructures:id8}\label{datastructures:tut-tuples}
我们知道链表和字符串有很多通用的属性，例如索引和切片操作。
它们是 \emph{序列} 类型（参见 \href{https://docs.python.org/3/library/stdtypes.html\#typesseq}{Sequence Types — list, tuple, range} ）中的两种。
因为 Python 是一个在不停进化的语言，也可能会加入其它的序列类型，这里介绍另一种标准序列类型： \emph{元组} 。

一个元组由数个逗号分隔的值组成，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{12345}\PYG{p}{,} \PYG{l+m+mi}{54321}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello!}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{12345}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t}
\PYG{g+go}{(12345, 54321, \PYGZsq{}hello!\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Tuples may be nested:}
\PYG{g+gp}{... }\PYG{n}{u} \PYG{o}{=} \PYG{n}{t}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{u}
\PYG{g+go}{((12345, 54321, \PYGZsq{}hello!\PYGZsq{}), (1, 2, 3, 4, 5))}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Tuples are immutable:}
\PYG{g+gp}{... }\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{88888}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
\PYG{g+gr}{TypeError}: \PYG{n}{\PYGZsq{}tuple\PYGZsq{} object does not support item assignment}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} but they can contain mutable objects:}
\PYG{g+gp}{... }\PYG{n}{v} \PYG{o}{=} \PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v}
\PYG{g+go}{([1, 2, 3], [3, 2, 1])}
\end{Verbatim}

如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可以有或没有括号，
不过经常括号都是必须的（如果元组是一个更大的表达式的一部分）。不能给元组的一个独立的元素赋值
（尽管你可以通过联接和切片来模拟）。另外你还可以创建包含可变对象的元组，例如链表。

虽然元组和列表很类似，它们经常被用来在不同的情况和不同的用途。
元组有很多用途。例如 (x, y) 坐标对，数据库中的员工记录等等。
元组就像字符串， \href{https://docs.python.org/3/glossary.html\#term-immutable}{不可变的}。通常包含不同种类的元素并通过分拆（参阅本节后面的内容) 或索引访问
（如果是 \href{https://docs.python.org/3/library/collections.html\#collections.namedtuple}{namedtuples}，甚至可以通过属性访问）。列表是 \href{https://docs.python.org/3/glossary.html\#term-mutable}{可变的} ，它们的元素通常是相同类型的并通过迭代访问。

一个特殊的问题是构造包含零个或一个元素的元组：为了适应这种情况，
语法上有一些额外的改变。一对空的括号可以创建空元组；
要创建一个单元素元组可以在值后面跟一个逗号（在括号中放入一个单值不够明确）。
丑陋，但是有效。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{empty} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{singleton} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}    \PYG{c}{\PYGZsh{} \PYGZlt{}\PYGZhy{}\PYGZhy{} note trailing comma}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{empty}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{singleton}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{singleton}
\PYG{g+go}{(\PYGZsq{}hello\PYGZsq{},)}
\end{Verbatim}

语句 \code{t = 12345, 54321, 'hello!'} 是 \emph{元组封装} （tuple packing）的一个例子：
值 \code{12345} ， \code{54321} 和 \code{'hello!'} 被封装进元组。其逆操作可能是这样:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{t}
\end{Verbatim}

这个调用等号右边可以是任何线性序列，称之为 \emph{序列拆封} 非常恰当。序列拆封要求左侧的变量数目与序列的元素个数相同。
要注意的是可变参数（multiple assignment ）其实只是元组封装和序列拆封的一个结合。


\section{集合}
\label{datastructures:id9}\label{datastructures:tut-sets}
Python 还包含了一个数据类型 —— \emph{set} （集合）。集合是一个无序不重复元素的集。
基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），
difference（差）和 sysmmetric difference（对称差集）等数学运算。

大括号或 \href{https://docs.python.org/3/library/stdtypes.html\#set}{set()} 函数可以用来创建集合。注意：想要创建空集合，你必须使用 \code{set()} 而不
是 \code{\{\}}。后者用于创建空字典，我们在下一节中将要介绍的一种数据结构。

以下是一个简单的演示:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{basket} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{orange}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{orange}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{banana}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{basket}\PYG{p}{)}                      \PYG{c}{\PYGZsh{} show that duplicates have been removed}
\PYG{g+go}{\PYGZob{}\PYGZsq{}orange\PYGZsq{}, \PYGZsq{}banana\PYGZsq{}, \PYGZsq{}pear\PYGZsq{}, \PYGZsq{}apple\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{orange}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{basket}                 \PYG{c}{\PYGZsh{} fast membership testing}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{crabgrass}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{basket}
\PYG{g+go}{False}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Demonstrate set operations on unique letters from two words}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abracadabra}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{alacazam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}                                  \PYG{c}{\PYGZsh{} unique letters in a}
\PYG{g+go}{\PYGZob{}\PYGZsq{}a\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}                              \PYG{c}{\PYGZsh{} letters in a but not in b}
\PYG{g+go}{\PYGZob{}\PYGZsq{}r\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}b\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\textbar{}} \PYG{n}{b}                              \PYG{c}{\PYGZsh{} letters in either a or b}
\PYG{g+go}{\PYGZob{}\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}m\PYGZsq{}, \PYGZsq{}z\PYGZsq{}, \PYGZsq{}l\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZam{}} \PYG{n}{b}                              \PYG{c}{\PYGZsh{} letters in both a and b}
\PYG{g+go}{\PYGZob{}\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b}                              \PYG{c}{\PYGZsh{} letters in a or b but not both}
\PYG{g+go}{\PYGZob{}\PYGZsq{}r\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}b\PYGZsq{}, \PYGZsq{}m\PYGZsq{}, \PYGZsq{}z\PYGZsq{}, \PYGZsq{}l\PYGZsq{}\PYGZcb{}}
\end{Verbatim}

类似 {\hyperref[datastructures:tut-listcomps]{\emph{\DUspan{}{列表解析}}}} (\autopageref*{datastructures:tut-listcomps})，这里有一种集合解析语法:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abracadabra}\PYG{l+s}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{x} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{\PYGZob{}\PYGZsq{}r\PYGZsq{}, \PYGZsq{}d\PYGZsq{}\PYGZcb{}}
\end{Verbatim}


\section{字典}
\label{datastructures:tut-dictionaries}\label{datastructures:id10}
另一个非常有用的 Python 内建数据类型是 \emph{字典} （参见 \href{https://docs.python.org/3/library/stdtypes.html\#typesmapping}{Mapping Types — dict} ）。
字典在某些语言中可能称为联合内存（ associative memories ）或联合数组（ associative arrays ）。
序列是以连续的整数为索引，与此不同的是，字典以 \emph{关键字} 为索引，关键字可以是任意不可变类型，
通常用字符串或数值。如果元组中只包含字符串和数字，它可以做为关键字，如果它直接或间接的包含了可变对象，
就不能当做关键字。不能用链表做关键字，因为链表可以用索引、切割或者 \code{append()} 和 \code{extend()} 等方法改变。

理解字典的最佳方式是把它看做无序的: \emph{键值对} 集合，
键必须是互不相同的（在同一个字典之内）。一对大括号创建一个空的字典： \code{\{\}} 。
初始化字典时，可以在大括号内放置一组逗号分隔的键值对，这也是字典输出的方式。

字典的主要操作是依据键来存储和析取值。也可以用 \code{del} 来删除键值对。
如果你用一个已经存在的关键字存储值，以前为该关键字分配的值就会被替换掉。试图从一个不存在的键中取值会导致错误。

对一个字典执行 \code{list(d.keys())} 将返回一个字典中所有关键字组成的无序列表
（如果你想要排序，只需使用 \code{sorted(d.keys()) ）}。\footnote{
调用 \code{d.keys()} 将会返回一个 \emph{dictionary view} 对象。
它支持成员检查以及迭代等操作，但是它的内容不是独立的原始字典 -- 它只是一个 \emph{视图}。
} 使用 \href{https://docs.python.org/3/reference/expressions.html\#in}{in} 关键字可以检查字典中是否存在某个关键字。

这里是使用字典的一个小示例:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tel} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jack}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4098}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sape}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4139}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tel}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{guido}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4127}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tel}
\PYG{g+go}{\PYGZob{}\PYGZsq{}sape\PYGZsq{}: 4139, \PYGZsq{}guido\PYGZsq{}: 4127, \PYGZsq{}jack\PYGZsq{}: 4098\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tel}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jack}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{4098}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{tel}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sape}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tel}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{irv}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4127}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tel}
\PYG{g+go}{\PYGZob{}\PYGZsq{}guido\PYGZsq{}: 4127, \PYGZsq{}irv\PYGZsq{}: 4127, \PYGZsq{}jack\PYGZsq{}: 4098\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{tel}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}irv\PYGZsq{}, \PYGZsq{}guido\PYGZsq{}, \PYGZsq{}jack\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{tel}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}guido\PYGZsq{}, \PYGZsq{}irv\PYGZsq{}, \PYGZsq{}jack\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{guido}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{tel}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jack}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{tel}
\PYG{g+go}{False}
\end{Verbatim}

\href{https://docs.python.org/3/library/stdtypes.html\#dict}{dict()} 构造函数可以直接从 key-value 对中创建字典:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dict}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sape}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4139}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{guido}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4127}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jack}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4098}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}sape\PYGZsq{}: 4139, \PYGZsq{}jack\PYGZsq{}: 4098, \PYGZsq{}guido\PYGZsq{}: 4127\PYGZcb{}}
\end{Verbatim}

此外，字典解析可以从任意的键值表达式中创建字典:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{\PYGZob{}}\PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\PYG{g+go}{\PYGZob{}2: 4, 4: 16, 6: 36\PYGZcb{}}
\end{Verbatim}

如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{sape}\PYG{o}{=}\PYG{l+m+mi}{4139}\PYG{p}{,} \PYG{n}{guido}\PYG{o}{=}\PYG{l+m+mi}{4127}\PYG{p}{,} \PYG{n}{jack}\PYG{o}{=}\PYG{l+m+mi}{4098}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}sape\PYGZsq{}: 4139, \PYGZsq{}jack\PYGZsq{}: 4098, \PYGZsq{}guido\PYGZsq{}: 4127\PYGZcb{}}
\end{Verbatim}


\section{循环技巧}
\label{datastructures:id12}\label{datastructures:tut-loopidioms}
在字典中循环时，关键字和对应的值可以使用 \code{items()} 方法同时解读出来:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{knights} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{gallahad}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the pure}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{robin}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the brave}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{knights}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{gallahad the pure}
\PYG{g+go}{robin the brave}
\end{Verbatim}

在序列中循环时，索引位置和对应值可以使用 \href{https://docs.python.org/3/library/functions.html\#enumerate}{enumerate()} 函数同时得到:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tic}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tac}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{toe}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{0 tic}
\PYG{g+go}{1 tac}
\PYG{g+go}{2 toe}
\end{Verbatim}

同时循环两个或更多的序列时，可以使用 \href{https://docs.python.org/3/library/functions.html\#zip}{zip()} 整体打包:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{questions} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{favorite color}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{answers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lancelot}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the holy grail}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{q}\PYG{p}{,} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{questions}\PYG{p}{,} \PYG{n}{answers}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{What is your \PYGZob{}0\PYGZcb{}?  It is \PYGZob{}1\PYGZcb{}.}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{What is your name?  It is lancelot.}
\PYG{g+go}{What is your quest?  It is the holy grail.}
\PYG{g+go}{What is your favorite color?  It is blue.}
\end{Verbatim}

需要逆向循环序列的话，先正向定位序列，然后调用 \href{https://docs.python.org/3/library/functions.html\#reversed}{reversed()} 函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{reversed}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{9}
\PYG{g+go}{7}
\PYG{g+go}{5}
\PYG{g+go}{3}
\PYG{g+go}{1}
\end{Verbatim}

要按排序后的顺序循环序列的话，使用 \href{https://docs.python.org/3/library/functions.html\#sorted}{sorted()} 函数，它不改动原序列，而是生成一个新的已排序的序列:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{basket} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{orange}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{orange}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{banana}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{basket}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{apple}
\PYG{g+go}{banana}
\PYG{g+go}{orange}
\PYG{g+go}{pear}
\end{Verbatim}

若要在循环内部修改正在遍历的列表，通常简单和安全的做法是创建一个
新的列表代替在遍历的列表（译者注：不修改正在遍历的列表):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{words} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{window}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{defenestrate}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{words}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{:}  \PYG{c}{\PYGZsh{} Loop over a slice copy of the entire list.}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{6}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{words}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{words}
\PYG{g+go}{[\PYGZsq{}defenestrate\PYGZsq{}, \PYGZsq{}cat\PYGZsq{}, \PYGZsq{}window\PYGZsq{}, \PYGZsq{}defenestrate\PYGZsq{}]}
\end{Verbatim}


\section{深入条件控制}
\label{datastructures:tut-conditions}\label{datastructures:id13}
\code{while} 和 \code{if} 语句中使用的条件不仅仅可以是比较符，它可以是任意的操作符。

比较操作符 \code{in} 和 \code{not in} 判断值是否在一个区间之内。
操作符 \code{is} 和 \code{is not} 比较两个对象是否相同；
这只和诸如链表这样的可变对象有关。所有的比较操作符具有相同的优先级，低于所有的数值操作。

比较操作符可以传递。例如 \code{a \textless{} b == c} 判断是否 \code{a} 小于 \code{b} 并且 \code{b} 等于 \code{c}。

比较操作可以通过逻辑操作符 \code{and} 和 \code{or} 组合，比较的结果可以用 \code{not} 来取反。
这些操作符的优先级又低于比较操作符，在它们之中，\code{not} 具有最高的优先级， \code{or} 优先级最低，
所以 \code{A and not B or C} 等于 \code{(A and (notB)) or C}。显然，括号是用于指定组合表达式的。

逻辑操作符 \code{and} 和 \code{or} 也称作短路操作符：它们的参数从左向右解析，
一旦结果可以确定就停止。例如，如果 \code{A} 和 \code{C} 为真而 \code{B} 为假， \code{A and B and C} 将不会判断 \code{C}。
作用于一个普通的非逻辑值时，短路操作符的返回值通常是最后一个变量。

可以把比较或其它逻辑表达式的返回值赋给一个变量，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{string1}\PYG{p}{,} \PYG{n}{string2}\PYG{p}{,} \PYG{n}{string3} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Trondheim}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Hammer Dance}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{non\PYGZus{}null} \PYG{o}{=} \PYG{n}{string1} \PYG{o+ow}{or} \PYG{n}{string2} \PYG{o+ow}{or} \PYG{n}{string3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{non\PYGZus{}null}
\PYG{g+go}{\PYGZsq{}Trondheim\PYGZsq{}}
\end{Verbatim}

需要注意的是 Python 与 C 不同，在表达式内部不能赋值。C 程序员经常对此抱怨，
不过它避免了一类在 C 程序中司空见惯的错误：想要在解析式中使 \code{==} 时误用了 \code{=} 操作符。


\section{比较序列和其它类型}
\label{datastructures:tut-comparing}\label{datastructures:id14}
序列对象可以与相同类型的其它对象比较。比较操作按 \emph{字典序} 进行：首先比较前两个元素，如果不同，
就决定了比较的结果；如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。
如果两个元素本身就是同样类型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就认为序列相等。
如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符串的字典序按照单字符的 ASCII 顺序排序。
下面是同类型序列之间比较的一些例子:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}              \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}              \PYG{o}{\PYGZlt{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ABC}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Pascal}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Python}\PYG{l+s}{\PYGZsq{}}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}           \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}                 \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}             \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{aa}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ab}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}   \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

需要注意的是如果通过 \code{\textless{}} 或者 \code{\textgreater{}} 比较的对象只要具有合适的比较方法就
是合法的。比如，混合数值类型是通过它们的数值进行比较的，所以 0 是等于 0.0 。
否则解释器将会触发一个 \href{https://docs.python.org/3/library/exceptions.html\#TypeError}{TypeError} 异常，而不是提供一个随意的结果。


\chapter{模块}
\label{modules:typeerror}\label{modules:id1}\label{modules::doc}\label{modules:tut-modules}
如果你退出 Python 解释器并重新进入，你做的任何定义（变量和函数）都会丢失。
因此，如果你想要编写一些更大的程序，你不应该直接使用解释器来编辑代码，而应该使用一个文本编辑器来编写代码，
然后运行这个代码文件。这就是传说中的 \emph{脚本}。随着你的程序变得越来越长，你可能想要将它分割成几个更易于维护的文件。
你也可能想在不同的程序中使用顺手的函数，而不是把代码在它们当中拷来拷去。

为了满足这些需要，Python 提供了一个方法，将代码定义写入文件，然后将它们作为脚本或者解释器的一个交互实例来使用。
这样的文件被称为 \emph{模块}；模块中的定义可以 \emph{导入} 到另一个模块或 \emph{主模块} 中（在脚本执行时可调用的变量集
位于最高级，并且处于计算器模式）。

模块是包括 Python 定义和声明的文件。文件名就是模块名加上 \code{.py} 后缀。
模块的模块名（做为一个字符串）可以由全局变量 \code{\_\_name\_\_} 得到。例如，
你可以用自己惯用的文件编辑器在当前目录下创建一个叫 fibo.py 的文件，录入如下内容:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Fibonacci numbers module}

\PYG{k}{def} \PYG{n+nf}{fib}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}    \PYG{c}{\PYGZsh{} write Fibonacci series up to n}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
    \PYG{k}{print}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{fib2}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:} \PYG{c}{\PYGZsh{} return Fibonacci series up to n}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n}{b} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{:}
        \PYG{n}{result}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

现在进入 Python 解释器并使用以下命令导入这个模块:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{fibo}
\end{Verbatim}

这样做不会直接把 \code{fibo} 中的函数导入当前的语义表；它只是引入了模块 \code{fibo}。
你可以通过模块名按如下方式访问这个函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fibo}\PYG{o}{.}\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fibo}\PYG{o}{.}\PYG{n}{fib2}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fibo}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}
\PYG{g+go}{\PYGZsq{}fibo\PYGZsq{}}
\end{Verbatim}

如果打算频繁使用一个函数，你可以将它赋予一个本地变量:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib} \PYG{o}{=} \PYG{n}{fibo}\PYG{o}{.}\PYG{n}{fib}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{g+go}{1 1 2 3 5 8 13 21 34 55 89 144 233 377}
\end{Verbatim}


\section{深入模块}
\label{modules:tut-moremodules}\label{modules:id2}
除了包含函数定义外，模块也可以包含可执行语句。这些语句一般用来初始化模块。
他们仅在 \emph{第一次} 被导入的地方执行一次。\footnote{
事实上函数定义既是“声明”又是“可执行体”；当函数名字进入全局符号表中，执行体是一个模块级别的函数定义。
}

每个模块都有自己私有的符号表，被模块内所有的函数定义作为全局符号表使用。
因此，模块的作者可以在模块内部使用全局变量，而无需担心它与某个用户的全局变量意外冲突。
从另一个方面讲，如果你确切的知道自己在做什么，你可以访问模块的全局变量就像引用模块函数的方法那样，\code{modname.itemname}。

模块可以导入其他的模块。一个好的习惯是将所有的 \href{https://docs.python.org/3/reference/simple\_stmts.html\#import}{import} 语句放在模块的开始（或者是脚本）处，但这并非强制。
被导入的模块名会放入当前模块的全局符号表中。

\href{https://docs.python.org/3/reference/simple\_stmts.html\#import}{import} 语句的一个变体是直接从被导入的模块中导入命名到本模块的符号表中。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fibo} \PYG{k+kn}{import} \PYG{n}{fib}\PYG{p}{,} \PYG{n}{fib2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{g+go}{1 1 2 3 5 8 13 21 34 55 89 144 233 377}
\end{Verbatim}

这样将不会从局域符号表中导入模块名（如上所示， \code{fibo} 没有定义）。

甚至有种方式可以导入模块中的所有定义项:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fibo} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{g+go}{1 1 2 3 5 8 13 21 34 55 89 144 233 377}
\end{Verbatim}

这样可以导入所有除了以下划线( \code{\_} )开头的命名。

需要注意的是在实践中往往不鼓励从一个模块或包中使用 \code{*} 导入所有，因为这样会让代码变得很难读。
不过，在交互式会话中这样用很方便省力。

\begin{notice}{note}{注解:}
出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；
或者，如果你就是想交互式的测试这么一个模块，可以用 \href{https://docs.python.org/3/library/imp.html\#imp.reload}{imp.reload()} 重新加载，例如 \code{import imp; imp.reload(modulename)}。
\end{notice}


\subsection{作为脚本来执行模块}
\label{modules:id4}\label{modules:tut-modulesasscripts}
当你使用以下方式运行 Python 模块时，模块中的代码便会被执行:

\begin{Verbatim}[commandchars=\\\{\}]
python fibo.py \PYGZlt{}arguments\PYGZgt{}
\end{Verbatim}

模块中的代码会被执行，就像导入它一样，不过此时 \code{\_\_name\_\_} 被设置为 \code{"\_\_main\_\_"}。这相当于，如果你在模块后加入如下代码:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{sys}
    \PYG{n}{fib}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

就可以让此文件像作为模块导入时一样作为脚本执行。此代码只有在模块作为 “main” 文件执行时才被调用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python fibo.py 50
1 1 2 3 5 8 13 21 34
\end{Verbatim}

如果模块被导入，不会执行这段代码:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{fibo}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{Verbatim}

这通常用来为模块提供一个便于测试的用户接口（将模块作为脚本执行测试集）。


\subsection{模块的搜索路径}
\label{modules:id5}\label{modules:tut-searchpath}
\index{module!search path}\index{search!path, module}\index{path!module search}
导入一个叫 \code{spam} 的模块时，解释器先在当前目录中搜索名为 \code{spam.py} 的文件。
如果没有找到的话，接着会到 \href{https://docs.python.org/3/library/sys.html\#sys.path}{sys.path} 变量中给出的目录列表中查找。 \href{https://docs.python.org/3/library/sys.html\#sys.path}{sys.path} 变量的初始值来自如下：
\begin{itemize}
\item {} 
输入脚本的目录（当没有指定文件时，指当前目录）。

\item {} 
环境变量 \href{https://docs.python.org/3/using/cmdline.html\#envvar-PYTHONPATH}{PYTHONPATH} 表示的目录列表中搜索
(这和 shell 变量 \index{PATH}\index{环境变量!PATH}\code{PATH} 具有一样的语法，即一系列目录名的列表)。

\item {} 
Python 默认安装路径中搜索。

\begin{notice}{note}{注解:}
在支持符号连接的文件系统中，输入的脚本所在的目录是符号连接指向的目录。
换句话说也就是包含符号链接的目录不会被加到目录搜索路径中。
\end{notice}

\end{itemize}

实际上，解释器由 \href{https://docs.python.org/3/library/sys.html\#sys.path}{sys.path} 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本
（或者当前目录）， \href{https://docs.python.org/3/using/cmdline.html\#envvar-PYTHONPATH}{PYTHONPATH} 和安装目录。这样就允许 Python 程序了解如何修改或替换模块搜索目录。
需要注意的是由于这些目录中包含有搜索路径中运行的脚本，所以这些脚本不应该和标准模块重名，
否则在导入模块时 Python 会尝试把这些脚本当作模块来加载。这通常会引发错误。
请参见 {\hyperref[modules:tut-standardmodules]{\emph{\DUspan{}{标准模块}}}} (\autopageref*{modules:tut-standardmodules}) 以了解更多的信息。


\subsection{“编译的” Python 文件}
\label{modules:python}
为了加快加载模块的速度，Python 会在 \code{\_\_pycache\_\_} 目录下以 \code{module.\emph{version}.pyc} 名字缓存每个模块编译后的版本，
这里的版本编制了编译后文件的格式。它通常会包含 Python 的版本号。例如，在 CPython 3.3 版中，spam.py 编译后的版本
将缓存为 \code{\_\_pycache\_\_/spam.cpython-33.pyc}。这种命名约定允许由不同发布和不同版本的 Python 编译的模块同时存在。

Python 会检查源文件与编译版的修改日期以确定它是否过期并需要重新编译。这是完全自动化的过程。
同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。

Python 不检查在两个不同环境中的缓存。首先，它会永远重新编译而且不会存储直接从命令行加载的模块。
其次，如果没有源模块它不会检查缓存。若要支持没有源文件（只有已经编译的文件）的发布，编译后的模块必须在源目录下，
并且必需没有源文件模块。

部分高级技巧:
\begin{itemize}
\item {} 
为了减少一个编译模块的大小，你可以在 Python 命令行中使用 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-O}{-O} 或者 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-OO}{-OO}。\href{https://docs.python.org/3/using/cmdline.html\#cmdoption-O}{-O} 参数删除了
断言语句，\href{https://docs.python.org/3/using/cmdline.html\#cmdoption-OO}{-OO} 参数删除了断言语句和 \_\_doc\_\_ 字符串。
因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。“优化的” 模块有一个 .pyo 后缀而不是 .pyc 后缀。
未来的版本可能会改变优化的效果。

\item {} 
来自 \code{.pyc} 文件或 \code{.pyo} 文件中的程序不会比来自 \code{.py} 文件的运行
更快；\code{.pyc} 或 \code{.pyo} 文件只是在它们加载的时候更快一些。

\item {} 
\href{https://docs.python.org/3/library/compileall.html\#module-compileall}{compileall} 模块可以为指定目录中的所有模块创建 \code{.pyc} 文件（或者使用 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-O}{-O} 参数创建 \code{.pyo} 文件）。

\item {} 
在 PEP 3147 中有很多关这一部分内容的细节，并且包含了一个决策流程。

\end{itemize}


\section{标准模块}
\label{modules:tut-standardmodules}\label{modules:id6}
\index{模块!sys}\index{sys!模块}
Python 带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册（此后称其为“库参考手册”）。
有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。
这既是为了提高效率，也是为了能够访问原生操作系统，例如系统调用。
这类模块集合是一个依赖于底层平台的配置选项。例如，\href{https://docs.python.org/3/library/winreg.html\#module-winreg}{winreg} 模块只提供在 Windows 系统上才有。
有一个具体的模块值得注意： \href{https://docs.python.org/3/library/sys.html\#module-sys}{sys} ，这个模块内置于所有的 Python 解释器。变量 \code{sys.ps1} 和 \code{sys.ps2} 定
义了主提示符和辅助提示符字符串:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sys}\PYG{o}{.}\PYG{n}{ps1}
\PYG{g+go}{\PYGZsq{}\PYGZgt{}\PYGZgt{}\PYGZgt{} \PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sys}\PYG{o}{.}\PYG{n}{ps2}
\PYG{g+go}{\PYGZsq{}... \PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sys}\PYG{o}{.}\PYG{n}{ps1} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{C\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{C\PYGZgt{} print(\PYGZsq{}Yuck!\PYGZsq{})}
\PYG{g+go}{Yuck!}
\PYG{g+go}{C\PYGZgt{}}
\end{Verbatim}

这两个变量只在解释器的交互模式下有意义。

变量 \code{sys.path} 是解释器模块搜索路径的字符串列表。它由环境变量 \href{https://docs.python.org/3/using/cmdline.html\#envvar-PYTHONPATH}{PYTHONPATH} 初始化，
如果没有设定 \href{https://docs.python.org/3/using/cmdline.html\#envvar-PYTHONPATH}{PYTHONPATH} ，就由内置的默认值初始化。你可以用标准的字符串操作修改它:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/ufs/guido/lib/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}


\section{dir() 函数}
\label{modules:dir}\label{modules:tut-dir}
内置函数 \href{https://docs.python.org/3/library/functions.html\#dir}{dir()} 用于按模块名搜索模块定义，它返回一个字符串类型的存储列表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{fibo}\PYG{o}{,} \PYG{n+nn}{sys}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{fibo}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}fib\PYGZsq{}, \PYGZsq{}fib2\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{sys}\PYG{p}{)}  
\PYG{g+go}{[\PYGZsq{}\PYGZus{}\PYGZus{}displayhook\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}excepthook\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}loader\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}\PYGZus{}\PYGZus{}package\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}stderr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}stdin\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}stdout\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}\PYGZus{}clear\PYGZus{}type\PYGZus{}cache\PYGZsq{}, \PYGZsq{}\PYGZus{}current\PYGZus{}frames\PYGZsq{}, \PYGZsq{}\PYGZus{}debugmallocstats\PYGZsq{}, \PYGZsq{}\PYGZus{}getframe\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}\PYGZus{}home\PYGZsq{}, \PYGZsq{}\PYGZus{}mercurial\PYGZsq{}, \PYGZsq{}\PYGZus{}xoptions\PYGZsq{}, \PYGZsq{}abiflags\PYGZsq{}, \PYGZsq{}api\PYGZus{}version\PYGZsq{}, \PYGZsq{}argv\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}base\PYGZus{}exec\PYGZus{}prefix\PYGZsq{}, \PYGZsq{}base\PYGZus{}prefix\PYGZsq{}, \PYGZsq{}builtin\PYGZus{}module\PYGZus{}names\PYGZsq{}, \PYGZsq{}byteorder\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}call\PYGZus{}tracing\PYGZsq{}, \PYGZsq{}callstats\PYGZsq{}, \PYGZsq{}copyright\PYGZsq{}, \PYGZsq{}displayhook\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}dont\PYGZus{}write\PYGZus{}bytecode\PYGZsq{}, \PYGZsq{}exc\PYGZus{}info\PYGZsq{}, \PYGZsq{}excepthook\PYGZsq{}, \PYGZsq{}exec\PYGZus{}prefix\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}executable\PYGZsq{}, \PYGZsq{}exit\PYGZsq{}, \PYGZsq{}flags\PYGZsq{}, \PYGZsq{}float\PYGZus{}info\PYGZsq{}, \PYGZsq{}float\PYGZus{}repr\PYGZus{}style\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}getcheckinterval\PYGZsq{}, \PYGZsq{}getdefaultencoding\PYGZsq{}, \PYGZsq{}getdlopenflags\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}getfilesystemencoding\PYGZsq{}, \PYGZsq{}getobjects\PYGZsq{}, \PYGZsq{}getprofile\PYGZsq{}, \PYGZsq{}getrecursionlimit\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}getrefcount\PYGZsq{}, \PYGZsq{}getsizeof\PYGZsq{}, \PYGZsq{}getswitchinterval\PYGZsq{}, \PYGZsq{}gettotalrefcount\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}gettrace\PYGZsq{}, \PYGZsq{}hash\PYGZus{}info\PYGZsq{}, \PYGZsq{}hexversion\PYGZsq{}, \PYGZsq{}implementation\PYGZsq{}, \PYGZsq{}int\PYGZus{}info\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}intern\PYGZsq{}, \PYGZsq{}maxsize\PYGZsq{}, \PYGZsq{}maxunicode\PYGZsq{}, \PYGZsq{}meta\PYGZus{}path\PYGZsq{}, \PYGZsq{}modules\PYGZsq{}, \PYGZsq{}path\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}path\PYGZus{}hooks\PYGZsq{}, \PYGZsq{}path\PYGZus{}importer\PYGZus{}cache\PYGZsq{}, \PYGZsq{}platform\PYGZsq{}, \PYGZsq{}prefix\PYGZsq{}, \PYGZsq{}ps1\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}setcheckinterval\PYGZsq{}, \PYGZsq{}setdlopenflags\PYGZsq{}, \PYGZsq{}setprofile\PYGZsq{}, \PYGZsq{}setrecursionlimit\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}setswitchinterval\PYGZsq{}, \PYGZsq{}settrace\PYGZsq{}, \PYGZsq{}stderr\PYGZsq{}, \PYGZsq{}stdin\PYGZsq{}, \PYGZsq{}stdout\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}thread\PYGZus{}info\PYGZsq{}, \PYGZsq{}version\PYGZsq{}, \PYGZsq{}version\PYGZus{}info\PYGZsq{}, \PYGZsq{}warnoptions\PYGZsq{}]}
\end{Verbatim}

无参数调用时，\href{https://docs.python.org/3/library/functions.html\#dir}{dir()} 函数返回当前定义的命名:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{fibo}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fib} \PYG{o}{=} \PYG{n}{fibo}\PYG{o}{.}\PYG{n}{fib}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dir}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}\PYGZus{}\PYGZus{}builtins\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}a\PYGZsq{}, \PYGZsq{}fib\PYGZsq{}, \PYGZsq{}fibo\PYGZsq{}, \PYGZsq{}sys\PYGZsq{}]}
\end{Verbatim}

注意该列表列出了所有类型的名称：变量，模块，函数，等等。

\index{模块!builtins}\index{builtins!模块}
\href{https://docs.python.org/3/library/functions.html\#dir}{dir()} 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 \href{https://docs.python.org/3/library/builtins.html\#module-builtins}{builtins} 中定义:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{builtins}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{builtins}\PYG{p}{)}  
\PYG{g+go}{[\PYGZsq{}ArithmeticError\PYGZsq{}, \PYGZsq{}AssertionError\PYGZsq{}, \PYGZsq{}AttributeError\PYGZsq{}, \PYGZsq{}BaseException\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}BlockingIOError\PYGZsq{}, \PYGZsq{}BrokenPipeError\PYGZsq{}, \PYGZsq{}BufferError\PYGZsq{}, \PYGZsq{}BytesWarning\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}ChildProcessError\PYGZsq{}, \PYGZsq{}ConnectionAbortedError\PYGZsq{}, \PYGZsq{}ConnectionError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}ConnectionRefusedError\PYGZsq{}, \PYGZsq{}ConnectionResetError\PYGZsq{}, \PYGZsq{}DeprecationWarning\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}EOFError\PYGZsq{}, \PYGZsq{}Ellipsis\PYGZsq{}, \PYGZsq{}EnvironmentError\PYGZsq{}, \PYGZsq{}Exception\PYGZsq{}, \PYGZsq{}False\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}FileExistsError\PYGZsq{}, \PYGZsq{}FileNotFoundError\PYGZsq{}, \PYGZsq{}FloatingPointError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}FutureWarning\PYGZsq{}, \PYGZsq{}GeneratorExit\PYGZsq{}, \PYGZsq{}IOError\PYGZsq{}, \PYGZsq{}ImportError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}ImportWarning\PYGZsq{}, \PYGZsq{}IndentationError\PYGZsq{}, \PYGZsq{}IndexError\PYGZsq{}, \PYGZsq{}InterruptedError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}IsADirectoryError\PYGZsq{}, \PYGZsq{}KeyError\PYGZsq{}, \PYGZsq{}KeyboardInterrupt\PYGZsq{}, \PYGZsq{}LookupError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}MemoryError\PYGZsq{}, \PYGZsq{}NameError\PYGZsq{}, \PYGZsq{}None\PYGZsq{}, \PYGZsq{}NotADirectoryError\PYGZsq{}, \PYGZsq{}NotImplemented\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}NotImplementedError\PYGZsq{}, \PYGZsq{}OSError\PYGZsq{}, \PYGZsq{}OverflowError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}PendingDeprecationWarning\PYGZsq{}, \PYGZsq{}PermissionError\PYGZsq{}, \PYGZsq{}ProcessLookupError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}ReferenceError\PYGZsq{}, \PYGZsq{}ResourceWarning\PYGZsq{}, \PYGZsq{}RuntimeError\PYGZsq{}, \PYGZsq{}RuntimeWarning\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}StopIteration\PYGZsq{}, \PYGZsq{}SyntaxError\PYGZsq{}, \PYGZsq{}SyntaxWarning\PYGZsq{}, \PYGZsq{}SystemError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}SystemExit\PYGZsq{}, \PYGZsq{}TabError\PYGZsq{}, \PYGZsq{}TimeoutError\PYGZsq{}, \PYGZsq{}True\PYGZsq{}, \PYGZsq{}TypeError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}UnboundLocalError\PYGZsq{}, \PYGZsq{}UnicodeDecodeError\PYGZsq{}, \PYGZsq{}UnicodeEncodeError\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}UnicodeError\PYGZsq{}, \PYGZsq{}UnicodeTranslateError\PYGZsq{}, \PYGZsq{}UnicodeWarning\PYGZsq{}, \PYGZsq{}UserWarning\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}ValueError\PYGZsq{}, \PYGZsq{}Warning\PYGZsq{}, \PYGZsq{}ZeroDivisionError\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}build\PYGZus{}class\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}\PYGZus{}\PYGZus{}debug\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}import\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}package\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}abs\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}all\PYGZsq{}, \PYGZsq{}any\PYGZsq{}, \PYGZsq{}ascii\PYGZsq{}, \PYGZsq{}bin\PYGZsq{}, \PYGZsq{}bool\PYGZsq{}, \PYGZsq{}bytearray\PYGZsq{}, \PYGZsq{}bytes\PYGZsq{}, \PYGZsq{}callable\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}chr\PYGZsq{}, \PYGZsq{}classmethod\PYGZsq{}, \PYGZsq{}compile\PYGZsq{}, \PYGZsq{}complex\PYGZsq{}, \PYGZsq{}copyright\PYGZsq{}, \PYGZsq{}credits\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}delattr\PYGZsq{}, \PYGZsq{}dict\PYGZsq{}, \PYGZsq{}dir\PYGZsq{}, \PYGZsq{}divmod\PYGZsq{}, \PYGZsq{}enumerate\PYGZsq{}, \PYGZsq{}eval\PYGZsq{}, \PYGZsq{}exec\PYGZsq{}, \PYGZsq{}exit\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}filter\PYGZsq{}, \PYGZsq{}float\PYGZsq{}, \PYGZsq{}format\PYGZsq{}, \PYGZsq{}frozenset\PYGZsq{}, \PYGZsq{}getattr\PYGZsq{}, \PYGZsq{}globals\PYGZsq{}, \PYGZsq{}hasattr\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}hash\PYGZsq{}, \PYGZsq{}help\PYGZsq{}, \PYGZsq{}hex\PYGZsq{}, \PYGZsq{}id\PYGZsq{}, \PYGZsq{}input\PYGZsq{}, \PYGZsq{}int\PYGZsq{}, \PYGZsq{}isinstance\PYGZsq{}, \PYGZsq{}issubclass\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}iter\PYGZsq{}, \PYGZsq{}len\PYGZsq{}, \PYGZsq{}license\PYGZsq{}, \PYGZsq{}list\PYGZsq{}, \PYGZsq{}locals\PYGZsq{}, \PYGZsq{}map\PYGZsq{}, \PYGZsq{}max\PYGZsq{}, \PYGZsq{}memoryview\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}min\PYGZsq{}, \PYGZsq{}next\PYGZsq{}, \PYGZsq{}object\PYGZsq{}, \PYGZsq{}oct\PYGZsq{}, \PYGZsq{}open\PYGZsq{}, \PYGZsq{}ord\PYGZsq{}, \PYGZsq{}pow\PYGZsq{}, \PYGZsq{}print\PYGZsq{}, \PYGZsq{}property\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}quit\PYGZsq{}, \PYGZsq{}range\PYGZsq{}, \PYGZsq{}repr\PYGZsq{}, \PYGZsq{}reversed\PYGZsq{}, \PYGZsq{}round\PYGZsq{}, \PYGZsq{}set\PYGZsq{}, \PYGZsq{}setattr\PYGZsq{}, \PYGZsq{}slice\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}sorted\PYGZsq{}, \PYGZsq{}staticmethod\PYGZsq{}, \PYGZsq{}str\PYGZsq{}, \PYGZsq{}sum\PYGZsq{}, \PYGZsq{}super\PYGZsq{}, \PYGZsq{}tuple\PYGZsq{}, \PYGZsq{}type\PYGZsq{}, \PYGZsq{}vars\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}zip\PYGZsq{}]}
\end{Verbatim}


\section{包}
\label{modules:tut-packages}\label{modules:id7}
包通常是使用用“圆点模块名”的结构化模块命名空间。例如，名为 \code{A.B} 的模块表示了名为 \code{A} 的包中
名为 \code{B} 的子模块。正如同用模块来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名
保存像 NumPy 或 Python Imaging Library 之类的不同类库架构可以避免模块之间的命名冲突。

假设你现在想要设计一个模块集（一个“包”）来统一处理声音文件和声音数据。
存在几种不同的声音格式（通常由它们的扩展名来标识，例如：\code{.wav}，
\code{.aiff}，\code{.au} ），于是，为了在不同类型的文件格式之间转换，你需要维护一个不断增长的包集合。
可能你还想要对声音数据做很多不同的操作（例如混音，添加回声，应用平衡功能，创建一个人造效果），
所以你要加入一个无限流模块来执行这些操作。你的包可能会是这个样子（通过分级的文件体系来进行分组）:

\begin{Verbatim}[commandchars=\\\{\}]
sound/                          Top\PYGZhy{}level package
      \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
\end{Verbatim}

当导入这个包时，Python 通过 \code{sys.path} 搜索路径查找包含这个包的子目录。

为了让 Python 将目录当做内容包，目录中必须包含 \code{\_\_init\_\_.py} 文件。这是为了防止目录中包含一个通用的名字，比如 string
它隐藏了稍后在模块搜索路径中出现的有效模块。最简单的情况下，只需要一个空的 \code{\_\_init\_\_.py} 文件即可。
当然它也可以执行包的初始化代码，或者定义稍后介绍的 \code{\_\_all\_\_} 变量。

用户可以每次只导入包里的特定模块，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sound.effects.echo}
\end{Verbatim}

这样就导入了 \code{sound.effects.echo} 子模块。它必需通过完整的名称来引用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sound}\PYG{o}{.}\PYG{n}{effects}\PYG{o}{.}\PYG{n}{echo}\PYG{o}{.}\PYG{n}{echofilter}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{delay}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n}{atten}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

导入包时有一个可以选择的方式:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sound.effects} \PYG{k+kn}{import} \PYG{n}{echo}
\end{Verbatim}

这样就加载了 \code{echo} 子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以如下方式调用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{echo}\PYG{o}{.}\PYG{n}{echofilter}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{delay}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n}{atten}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

还有另一种变体用于直接导入函数或变量:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sound.effects.echo} \PYG{k+kn}{import} \PYG{n}{echofilter}
\end{Verbatim}

这样就又一次加载了 \code{echo} 子模块，但这样就可以直接调用它的 \code{echofilter()} 函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{echofilter}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{,} \PYG{n}{output}\PYG{p}{,} \PYG{n}{delay}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n}{atten}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

需要注意的是使用 \code{from package import item} 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），
也可以是包中定义的其它命名，像函数、类或变量。\code{import} 语句首先核对是否包中有这个子项，如果没有，
它假定这是一个模块，并尝试加载它。如果没有找到它，会引发一个  \href{https://docs.python.org/3/library/exceptions.html\#ImportError}{ImportError} 异常。

相反，使用类似 \code{import item.subitem.subsubitem} 这样的语法时，这些子项必须是包，
最后的子项可以是包或模块，但不能是前面子项中定义的类、函数或变量。


\subsection{从 * 导入包}
\label{modules:id8}\label{modules:tut-pkg-import-star}
\index{\_\_all\_\_}
那么当用户写下 \code{from sound.Effects import *} 时会发生什么事？理想中，总是希望在文件系统中找出包中所有的子模块，
然后导入它们。这可能会花很长的时间，并且导入的子模块应该只能被显示导入的时候可能会出现非意料的边界效应。

对于包的作者来说唯一的解决方案就是给提供一个明确的包索引。\href{https://docs.python.org/3/reference/simple\_stmts.html\#import}{import} 语句按如下条件进行转换：
执行 \code{from package import *} 时，如果包中的 \code{\_\_init\_\_.py} 代码定义了一个名为 \code{\_\_all\_\_} 的列表，
就会按照列表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个列表。
如果包作者不想 import * 的时候导入他们的包中所有模块，那么也可能会决定不支持它（ import * ）。
例如， \code{sound/effects/\_\_init\_\_.py} 这个文件可能包括如下代码:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{\PYGZus{}\PYGZus{}all\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{surround}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{reverse}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

这意味着 \code{from Sound.Effects import *} 语句会从 \code{sound} 包中导入以上三个已命名的子模块。

如果没有定义 \code{\_\_all\_\_} ， \code{from Sound.Effects import *} 语句 \emph{不会} 从 \code{sound.effects} 包中
导入所有的子模块到当前的命名空间。只能确定的是导入了 \code{sound.effects}  包
（可能会运行 \code{\_\_init\_\_.py} 中的初始化代码）以及包中定义的所有命名会随之导入。
这包括了 \code{\_\_init\_\_.py} 中任何的定义名称（以及显示导入的子模块）。
同样也包括了前面的 \href{https://docs.python.org/3/reference/simple\_stmts.html\#import}{import} 语句从包中显示导入的子模块，考虑以下代码:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sound.effects.echo}
\PYG{k+kn}{import} \PYG{n+nn}{sound.effects.surround}
\PYG{k+kn}{from} \PYG{n+nn}{sound.effects} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

在这个例子中，\code{echo} 和 \code{surround} 模块导入到了当前的命名空间，
这是因为执行 \code{from...import} 语句时它们已经定义在 \code{sound.effects} 包中了（定义了 \code{\_\_all\_\_} 时也会同样工作）。

尽管某些模块设计了使用 \code{import *} 时它只导入符合要求的模块，但仍然不建议在生产代码中使用这种写法。

记住，\code{from Package import specific\_submodule} 没有错误！事实上，除非导入的模块需要使用
其它包中的同名子模块，否则这是推荐的写法。


\subsection{包内引用}
\label{modules:id9}
如果包中使用了子包结构（就像示例中的 \code{sound} 包），可以按绝对位置从相邻的包中引入子模块。
例如，如果 \code{sound.filters.vocoder} 包需要使用 \code{sound.effects} 包中的 \code{echo} 模块，
它可以 \code{from Sound.Effects import echo}。

你可以用这样的形式 \code{from module import name} 来相对位置导入。
这些相对导入用点号标明导入当前和上级包。以 \code{surround} 模块为例，你可以这样用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{.} \PYG{k+kn}{import} \PYG{n}{echo}
\PYG{k+kn}{from} \PYG{n+nn}{..} \PYG{k+kn}{import} \PYG{n}{formats}
\PYG{k+kn}{from} \PYG{n+nn}{..filters} \PYG{k+kn}{import} \PYG{n}{equalizer}
\end{Verbatim}

需要注意的是相对位置导入都是基于当前模块的。因为主模块的名字总是 \code{"\_\_main\_\_"}，
Python 应用程序的主模块应该总是用绝对导入。


\subsection{多重目录中的包}
\label{modules:id10}
包还支持一些其他的属性， \href{https://docs.python.org/3/reference/import.html\#\_\_path\_\_}{\_\_path\_\_}。
在包的 \code{\_\_init\_\_.py} 文件代码执行之前，该变量初始化一个目录名列表。
该变量可以修改，它作用于包中的子包和模块的搜索功能。

这个功能可以用于扩展包中的模块集，不过它不常用。


\chapter{输入和输出}
\label{inputoutput:importerror}\label{inputoutput:tut-io}\label{inputoutput:id1}\label{inputoutput::doc}
一个程序可以有几种输出方式：以人类可读的方式打印数据，或者写入一个文件供以后使用。本章将讨论几种可能性。


\section{格式化输出}
\label{inputoutput:id2}\label{inputoutput:tut-formatting}
我们有两种大相径庭地输出值方法：\emph{表达式语句} 和 \href{https://docs.python.org/3/library/functions.html\#print}{print()} 函数
（第三种方法是使用文件对象的 \code{write()} 方法，标准文件输出可以参考 \code{sys.stdout}，详细内容参见库参考手册）。

通常，你想要对输出做更多的格式控制，而不是简单的换行输出。有两种方法可以格式化你的输出：
第一种方法是由你自己处理整个字符串，通过使用字符串切割和连接操作可以创建任何你想要的输出形式。
string 类型包含一些将字符串填充到指定列宽度的有用操作，随后就会讨论这些。
第二种方法是使用 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 方法。
\begin{quote}

\href{https://docs.python.org/3/library/string.html\#module-string}{string} 模块包含了一个 \code{Template} 类，它提供了另外一种替换字符串中值的方法。
\end{quote}

当然，还有一个问题，如何将值转化为字符串？很幸运，Python 有办法将任意值转为字符串：
将它传入 \href{https://docs.python.org/3/library/functions.html\#repr}{repr()} 或 \href{https://docs.python.org/3/library/stdtypes.html\#str}{str()} 函数。

函数 \href{https://docs.python.org/3/library/stdtypes.html\#str}{str()} 用于将值转化为适合于人阅读的形式，而 \href{https://docs.python.org/3/library/functions.html\#repr}{repr()} 转化为供解释器读取的形式
（如果没有相应的语法，则会引发 \href{https://docs.python.org/3/library/exceptions.html\#SyntaxError}{SyntaxError} 异常）。某对象没有适合于人阅读的形式的话，\href{https://docs.python.org/3/library/stdtypes.html\#str}{str()} 会
返回与 \href{https://docs.python.org/3/library/functions.html\#repr}{repr()} 等同的值。很多类型，诸如数值、链表、字典这样的结构，都有着统一的解读方式。
字符串和浮点数，有着独特的解读方式。

下面有些例子:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Hello, world.}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Hello, world.\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{}\PYGZsq{}Hello, world.\PYGZsq{}\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}0.14285714285714285\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{*} \PYG{l+m+mf}{3.25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{200} \PYG{o}{*} \PYG{l+m+mi}{200}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of x is }\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, and y is }\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{The value of x is 32.5, and y is 40000...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} The repr() of a string adds string quotes and backslashes:}
\PYG{g+gp}{... }\PYG{n}{hello} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello, world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hellos} \PYG{o}{=} \PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{hello}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{hellos}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}hello, world\PYGZbs{}n\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} The argument to repr() may be any Python object:}
\PYG{g+gp}{... }\PYG{n+nb}{repr}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eggs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{}(32.5, 40000, (\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}eggs\PYGZsq{}))\PYGZdq{}}
\end{Verbatim}

有两种方式可以写平方和立方表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rjust}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rjust}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{c}{\PYGZsh{} Note use of \PYGZsq{}end\PYGZsq{} on previous line}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rjust}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{ 1   1    1}
\PYG{g+go}{ 2   4    8}
\PYG{g+go}{ 3   9   27}
\PYG{g+go}{ 4  16   64}
\PYG{g+go}{ 5  25  125}
\PYG{g+go}{ 6  36  216}
\PYG{g+go}{ 7  49  343}
\PYG{g+go}{ 8  64  512}
\PYG{g+go}{ 9  81  729}
\PYG{g+go}{10 100 1000}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0:2d\PYGZcb{} \PYGZob{}1:3d\PYGZcb{} \PYGZob{}2:4d\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{ 1   1    1}
\PYG{g+go}{ 2   4    8}
\PYG{g+go}{ 3   9   27}
\PYG{g+go}{ 4  16   64}
\PYG{g+go}{ 5  25  125}
\PYG{g+go}{ 6  36  216}
\PYG{g+go}{ 7  49  343}
\PYG{g+go}{ 8  64  512}
\PYG{g+go}{ 9  81  729}
\PYG{g+go}{10 100 1000}
\end{Verbatim}

(注意第一个例子，\href{https://docs.python.org/3/library/functions.html\#print}{print()} 在每列之间加了一个空格，它总是在参数间加入空格。)

以上是一个 \href{https://docs.python.org/3/library/stdtypes.html\#str.rjust}{str.rjust()} 方法的演示，它把字符串输出到一列，并通过向左侧填充空格来使其右对齐。
类似的方法还有 \href{https://docs.python.org/3/library/stdtypes.html\#str.ljust}{str.ljust()} 和 \href{https://docs.python.org/3/library/stdtypes.html\#str.center}{str.center()}。这些函数只是输出新的字符串，并不改变什么。
如果输出的字符串太长，它们也不会截断它，而是原样输出，这可能会打乱你原来的输出格式，
不过通常比直接截断字符串要好，因为可能会误导这个值。
（如果你确实需要截断它，可以使用切片操作，例如：\code{x.ljust(n){[}:n{]}} ）。

还有另一个方法， \href{https://docs.python.org/3/library/stdtypes.html\#str.zfill}{str.zfill()} 它用于向数值的字符串表达左侧填充 0。该函数还可以正确理解正负号:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{12}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{zfill}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}00012\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}3.14}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{zfill}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZhy{}003.14\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{3.14159265359}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{zfill}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}3.14159265359\PYGZsq{}}
\end{Verbatim}

方法 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 的基本用法如下:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{We are the \PYGZob{}\PYGZcb{} who say }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZob{}\PYGZcb{}!}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{knights}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ni}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{We are the knights who say \PYGZdq{}Ni!\PYGZdq{}}
\end{Verbatim}

大括号和其中的字符会被替换成传入 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 的参数。大括号中的数值指明使用传入 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 方法的对象中的哪一个:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0\PYGZcb{} and \PYGZob{}1\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eggs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{spam and eggs}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}1\PYGZcb{} and \PYGZob{}0\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eggs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{eggs and spam}
\end{Verbatim}

如果在 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 调用时使用关键字参数，可以通过参数名来引用值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This \PYGZob{}food\PYGZcb{} is \PYGZob{}adjective\PYGZcb{}.}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}
\PYG{g+gp}{... }      \PYG{n}{food}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{adjective}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{absolutely horrible}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{This spam is absolutely horrible.}
\end{Verbatim}

位置参数和关键字参数可以随意组合:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The story of \PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}, and \PYGZob{}other\PYGZcb{}.}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Bill}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Manfred}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+go}{                                                       other=\PYGZsq{}Georg\PYGZsq{}))}
\PYG{g+go}{The story of Bill, Manfred, and Georg.}
\end{Verbatim}

\code{'!a'} (应用于 \href{https://docs.python.org/3/library/functions.html\#ascii}{ascii()})，\code{'!s'} （应用于 \href{https://docs.python.org/3/library/stdtypes.html\#str}{str()} ）和 \code{'!r'} （应用于 \href{https://docs.python.org/3/library/functions.html\#repr}{repr()} ）可以在格式化之前转换值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of PI is approximately \PYGZob{}\PYGZcb{}.}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{The value of PI is approximately 3.14159265359.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of PI is approximately \PYGZob{}!r\PYGZcb{}.}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{The value of PI is approximately 3.141592653589793.}
\end{Verbatim}

字段名后允许可选的 \code{':'} 和格式指令。这允许对值的格式化加以更深入的控制。下例将 Pi 转为三位精度。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of PI is approximately \PYGZob{}0:.3f\PYGZcb{}.}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{The value of PI is approximately 3.142.}
\end{Verbatim}

在字段后的 \code{':'} 后面加一个整数会限定该字段的最小宽度，这在美化表格时很有用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{table} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sjoerd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4127}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jack}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4098}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Dcab}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{7678}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{phone} \PYG{o+ow}{in} \PYG{n}{table}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0:10\PYGZcb{} ==\PYGZgt{} \PYGZob{}1:10d\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{phone}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{Jack       ==\PYGZgt{}       4098}
\PYG{g+go}{Dcab       ==\PYGZgt{}       7678}
\PYG{g+go}{Sjoerd     ==\PYGZgt{}       4127}
\end{Verbatim}

如果你有个实在是很长的格式化字符串，而你又不想分割它，那么用命名来引用被格式化的变量比位置来得更好。
有个简单的方法，可以传入一个字典，用中括号( \code{'{[}{]}'} )访问它的键:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{table} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sjoerd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4127}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jack}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4098}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Dcab}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{8637678}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jack: \PYGZob{}0[Jack]:d\PYGZcb{}; Sjoerd: \PYGZob{}0[Sjoerd]:d\PYGZcb{}; }\PYG{l+s}{\PYGZsq{}}
\PYG{g+go}{          \PYGZsq{}Dcab: \PYGZob{}0[Dcab]:d\PYGZcb{}\PYGZsq{}.format(table))}
\PYG{g+go}{Jack: 4098; Sjoerd: 4127; Dcab: 8637678}
\end{Verbatim}

也可以用 ‘**’ 标志将这个字典以关键字参数的方式传入:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{table} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sjoerd}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4127}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jack}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4098}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Dcab}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{8637678}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jack: \PYGZob{}Jack:d\PYGZcb{}; Sjoerd: \PYGZob{}Sjoerd:d\PYGZcb{}; Dcab: \PYGZob{}Dcab:d\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{table}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Jack: 4098; Sjoerd: 4127; Dcab: 8637678}
\end{Verbatim}

这种方式与新的内置函数 \href{https://docs.python.org/3/library/functions.html\#vars}{vars()} 组合使用非常有效。该函数返回包含所有局部变量的字典。

要进一步了解字符串格式化方法 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()}，参见 \href{https://docs.python.org/3/library/string.html\#formatstrings}{格式字符串语法}。


\subsection{旧式的字符串格式化}
\label{inputoutput:id3}
操作符 \code{\%} 也可以用于字符串格式化。它类似 \code{sprintf()}-style 的方式解析左参数，
然后将右参数应用于对应的左参数之上，最后得到格式化操作后生成的字符串，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The value of PI is approximately }\PYG{l+s+si}{\PYGZpc{}5.3f}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\PYG{g+go}{The value of PI is approximately 3.142.}
\end{Verbatim}

更多的信息可以参见 \href{https://docs.python.org/3/library/stdtypes.html\#old-string-formatting}{printf-style String Formatting} 一节。


\section{文件读写}
\label{inputoutput:id4}\label{inputoutput:tut-files}
\index{內置函数!open}\index{open!內置函数}\index{对象!file}\index{file!对象}
函数 \href{https://docs.python.org/3/library/functions.html\#open}{open()} 返回一个 \href{https://docs.python.org/3/glossary.html\#term-file-object}{文本文件} 对象，通常使用到两个参数：\code{open(filename, mode)}。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{workfile}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

第一个参数是一个含有文件名的字符串。第二个参数也是一个字符串，含有描述如何使用该文件的几个字符。
\emph{mode} 为 \code{'r'} 时表示只是读取文件；\code{'w'} 表示只是写入文件（已经存在的同名文件将被删掉）；
\code{'a'} 表示打开文件进行追加，写入到文件中的任何数据将自动添加到末尾。
\code{'r+'} 表示打开文件进行读取和写入。\emph{mode} 参数是可选的，默认为 \code{'r'}。

通常，文件以 \emph{文本模式} 打开，这意味着，你从文件读出和向文件写入的字符串会被特定的编码方式编码。
如果编码没有指定， 默认的编码方式依平台而定（请查看 \code{open()} ）。
模式后面加个 \code{'b'} 表示以 \emph{二进制模式} 打开文件：数据会以字节对象的形式读出和写入。
这种模式应该用于所有不包含文本的文件。

在文本模式下，读取时默认会将平台有关的行结束符（Unix上是 \code{\textbackslash{}n} , Windows上是 \code{\textbackslash{}r\textbackslash{}n}）转换为 \code{\textbackslash{}n}。
在文本模式下写入时，默认会将出现的 \code{\textbackslash{}n} 转换成平台有关的行结束符。这种暗地里的修改对 ASCII 文本文件没有问题，
但会损坏 \code{JPEG} 或 \code{EXE} 这样的二进制文件中的数据。使用二进制模式读写此类文件时要特别小心。


\subsection{文件对象的方法}
\label{inputoutput:tut-filemethods}\label{inputoutput:id5}
本节中的示例都默认文件对象 \code{f} 已经创建。

要读取文件内容，需要调用 \code{f.read(size)} 方法，该方法读取若干数量的数据并以字符串形式返回其内容，
\emph{size} 是可选的数字参数。如果没有指定 \emph{size} 或者指定为负数，就会读取并返回整个文件。
当文件大小为当前机器内存两倍时，就会产生问题。否则，会尽可能按比较大的 \emph{size} 读取和返回数据。
如果读到了文件末尾，\code{f.read()} 会返回一个空字符串（\code{'{'}}）:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}This is the entire file.\PYGZbs{}n\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{Verbatim}

\code{f.readline()} 从文件中读取单独一行，字符串结尾会自动加上一个换行符（ \code{\textbackslash{}n} ），
只有当文件最后一行没有以换行符结尾时，这一操作才会被忽略。这样返回值就不会有混淆，
如果 \code{f.readline()} 返回一个空字符串，那就表示到达了文件末尾，如果是一个空行，就会描述为 \code{'\textbackslash{}n'}，
一个只包含换行符的字符串:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}This is the first line of the file.\PYGZbs{}n\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Second line of the file\PYGZbs{}n\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{Verbatim}

你可以循环遍历文件对象来读取文件中的每一行。这是一种内存高效、快速，并且代码简介的方式:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{This is the first line of the file.}
\PYG{g+go}{Second line of the file}
\end{Verbatim}

如果你想把文件中的所有行读到一个列表中，你也可以使用 \code{list(f)} 或者 \code{f.readlines()}。

\code{f.write(string)} 方法将 \emph{string} 的内容写入到文件，并返回写入字符的长度:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This is a test}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{15}
\end{Verbatim}

想要写入其他非字符串内容，首先要将它转换为字符串:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{value} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the answer}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{18}
\end{Verbatim}

当在二进制模式下 \code{f.tell()} 返回一个整数，代表文件对象在文件中的指针位置，该数值计量了自文件开头到指针处的字节数，
如果是在文本模式下，将得到一个模糊的数值。

需要改变文件对象指针的话，使用 \code{f.seek(offset,from\_what)} 方法。指针在该操作中从指定的引用位置移动 \emph{offset} 字节，
引用位置由 \emph{from\_what} 参数指定。 \emph{from\_what} 值为 0 表示从文件起始处开始，1 表示从当前文件指针位置开始，
2 表示自文件末尾开始。\emph{from\_what} 可以省略，默认值为零，即从文件头开始:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{workfile}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{b}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0123456789abcdef}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{16}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}     \PYG{c}{\PYGZsh{} Go to the 6th byte in the file}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{b\PYGZsq{}5\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{seek}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c}{\PYGZsh{} Go to the 3rd byte before the end}
\PYG{g+go}{13}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{b\PYGZsq{}d\PYGZsq{}}
\end{Verbatim}

在文本文件中（没有以 \code{b} 模式打开），只允许从文件头开始（有个例外是用 \code{seek(0, 2)} 寻找文件的最末尾处），
并且合法的 \emph{偏移} 值只能是 \code{f.tell()} 返回的值或者是零。其它任何 \emph{偏移} 值都会产生未定义的行为。

当你使用完一个文件时，调用 \code{f.close()} 方法就可以关闭它并释放其占用的所有系统资源。
在调用 \code{f.close()} 方法后，试图再次使用文件对象将会自动失败。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{ValueError}: \PYG{n}{I/O operation on closed file}
\end{Verbatim}

用关键字 \href{https://docs.python.org/3/reference/compound\_stmts.html\#with}{with} 处理文件对象是个好习惯。它的优势之处在于文件用完后会自动关闭，
就算发生异常也没关系。它是 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try}-\href{https://docs.python.org/3/reference/compound\_stmts.html\#finally}{finally} 块的简写:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{workfile}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{read\PYGZus{}data} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{closed}
\PYG{g+go}{True}
\end{Verbatim}

文件对象还有一些不太常用的附加方法，比如 \code{isatty()} 和 \code{truncate()} 它们并不常用，
详细信息请查看库参考手册中关于文件对象的完整指南。


\subsection{使用 json 存储结构化数据}
\label{inputoutput:tut-json}\label{inputoutput:json}
\index{模块!json}\index{json!模块}
从文件中读写字符串很容易。数值就要多费点儿周折，因为 \code{read()} 方法只会返回字符串，
可以将其传入 \href{https://docs.python.org/3/library/functions.html\#int}{int()} 这样的函数，就可以将 \code{'123'} 这样的字符串转换为对应的数值 123 。
当你想要保存更为复杂的数据类型时，例如嵌套的列表和字典，解析和序列化它们将变得很复杂。

好在用户并非得自己编写和调试保存复杂数据类型的代码，Python 允许你使用常用的数据交换格
式 \href{http://json.org/}{JSON（JavaScript Object Notation）}。标准模块 \href{https://docs.python.org/3/library/json.html\#module-json}{json} 可以接受 Python 数据结构，
并将它们转换为字符串的形式；此过程称为 \textbf{序列化}。从字符串表示形式重新构建数据结构称为 \textbf{反序列化}。
序列化和反序列化可以使对象以字符串的形式存储在文件或者数据中，也可以通过网络连接传送给远程的机器。

\begin{notice}{note}{注解:}
JSON 格式经常用于现代应用程序中进行数据交换。许多程序员都已经熟悉它了，使它成为相互协作的一个不错的选择。
\end{notice}

如果你有一个对象 \code{x}，你可以用简单的一行代码查看其 JSON 字符串的描述信息:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{json}\PYG{o}{.}\PYG{n}{dumps}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{simple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}[1, \PYGZdq{}simple\PYGZdq{}, \PYGZdq{}list\PYGZdq{}]\PYGZsq{}}
\end{Verbatim}

\href{https://docs.python.org/3/library/json.html\#json.dumps}{dumps()} 函数的另外一个变体 \href{https://docs.python.org/3/library/json.html\#json.dump}{dump()}，直接将对象序列化到一个文件。所以如果 \code{f} 是为写入而打开
的 \href{https://docs.python.org/3/glossary.html\#term-file-object}{文本文件} 对象，我们可以这样做:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{json}\PYG{o}{.}\PYG{n}{dump}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}
\end{Verbatim}

为了重新解码对象，假设 \code{f} 是为读取而打开的 \href{https://docs.python.org/3/glossary.html\#term-file-object}{文本文件} 对象:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{json}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\end{Verbatim}

这种简单的序列化技术可以处理列表和字典，但序列化任意类实例为 JSON 需要一点额外的努力。
\href{https://docs.python.org/3/library/json.html\#module-json}{json} 模块的参考手册对此有详细的解释。


\strong{参见:}


\href{https://docs.python.org/3/library/pickle.html\#module-pickle}{pickle} - pickle 模块

与 {\hyperref[inputoutput:tut-json]{\emph{\DUspan{}{JSON}}}} (\autopageref*{inputoutput:tut-json}) 不同，\emph{pickle} 是一个协议，它允许任意复杂的 Python 对象的序列化。
因此，它只能用于 Python 而不能用来与其他语言编写的应用程序进行通信。
默认情况下它也是不安全的：如果反序列化数据由熟练的攻击者精心设计并来自于一个不受信任源的话，
可能执行恶意代码。




\chapter{错误和异常}
\label{errors:id1}\label{errors::doc}\label{errors:tut-errors}\label{errors:pickle}
至今为止还没有进一步的谈论过错误信息，不过在你已经尝试过的那些例子中，可能已经遇到过一些。
Python 中（至少）有两种错误：语法错误和异常（ \emph{syntax errors} 和 \emph{exceptions} ）。


\section{语法错误}
\label{errors:tut-syntaxerrors}\label{errors:id2}
语法错误，也被称作解析错误，也许是你学习 Python 过程中最常看到的:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n+nb+bp}{True} \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Hello world}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{  File \PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}, line 1, in ?}
\PYG{g+go}{    while True print(\PYGZsq{}Hello world\PYGZsq{})}
\PYG{g+go}{                   \PYGZca{}}
\PYG{g+go}{SyntaxError: invalid syntax}
\end{Verbatim}

语法分析器指出错误行，并且在检测到错误的位置前面显示一个小“箭头”。
错误是由箭头 \emph{前面} 所标记的代码引起的： 这个例子中，函数 \href{https://docs.python.org/3/library/functions.html\#print}{print()} 被发现存在错误，
因为它前面少了一个冒号（ \code{':'} ）。 错误会输出文件名和行号，因此如果错误是在脚本中出现的话
你就知道去哪里检查错误了。


\section{异常}
\label{errors:tut-exceptions}\label{errors:id3}
即使一条语句或表达式在语法上是正确的，当试图执行它时也可能会引发错误。
运行期检测到的错误称为 \emph{异常}，并且程序不会无条件的崩溃：很快，你将会学到如何在 Python 程序中处理它们。
然而，大多数异常都不会被程序处理，像这里展示的一样最终会产生一个错误信息:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{ZeroDivisionError}: \PYG{n}{int division or modulo by zero}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{spam}\PYG{o}{*}\PYG{l+m+mi}{3}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{NameError}: \PYG{n}{name \PYGZsq{}spam\PYGZsq{} is not defined}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{2}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{TypeError}: \PYG{n}{Can\PYGZsq{}t convert \PYGZsq{}int\PYGZsq{} object to str implicitly}
\end{Verbatim}

错误信息的最后一行指出发生了什么错误。异常也有不同的类型，
异常类型作为错误信息的一部分被显示出来：示例中的异常分别为 零除错误（ \href{https://docs.python.org/3/library/exceptions.html\#ZeroDivisionError}{ZeroDivisionError} ） ，
命名错误（ \href{https://docs.python.org/3/library/exceptions.html\#NameError}{NameError}） 和 类型错误（ \href{https://docs.python.org/3/library/exceptions.html\#TypeError}{TypeError} ）。打印错误信息时，异常的类型作为异常的内置名显示。
对于所有的内置异常都是如此，不过用户自定义异常就不一定了（尽管这是一个很有用的约定）。
标准异常名是内置的标识（不是保留关键字）。

下面将详细描述异常类型以及怎么引发异常

错误信息的前半部分以堆栈的形式列出异常发生的位置。通常在堆栈中列出了源代码行，然而，来自标准输入的源码不会显示出来。

\href{https://docs.python.org/3/library/exceptions.html\#bltin-exceptions}{内置的异常} 列出了内置异常和它们的含义。


\section{异常处理}
\label{errors:id4}\label{errors:tut-handling}
通过编程来处理要处理的异常是可以的。看一下下面的例子：
它会一直要求用户输入，直到输入一个合法的整数为止，但允许用户中断这个程序（使用 \code{Control-C} 或系统支持的任何方法）。
注意：用户产生的中断会引发一个 \href{https://docs.python.org/3/library/exceptions.html\#KeyboardInterrupt}{KeyboardInterrupt} 异常。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Please enter a number: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }        \PYG{k}{break}
\PYG{g+gp}{... }    \PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oops!  That was no valid number.  Try again...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\end{Verbatim}

\href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句按如下方式工作。
\begin{itemize}
\item {} 
首先，执行 \emph{try 分句} （在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 和 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 关键字之间的部分）。

\item {} 
如果没有异常发生， \emph{except 分句}  在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句执行完毕后就被跳过。

\item {} 
如果在 try 分句执行过程中发生了异常，那么该分句其余的部分就会被忽略。
如果异常匹配于 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 关键字后面指定的异常类型，就执行对应的 except 分句。然后继续执行 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句之后的代码。

\item {} 
如果发生了一个异常，在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 分句中没有与之匹配的分支，它就会传递到上一级 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try}  语句中。
如果最终仍没找到对应的处理语句，它就成为一个 \emph{未处理异常}，从而终止程序运行，并且显示异常信息。

\end{itemize}

一个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句可能包含多个 except 分句，分别指定处理不同的异常。
至多只会有一个分支被执行。异常处理程序只会处理对应的 try 分句中发生的异常，在同一个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句中，
其他分句中发生的异常则不作处理。一个 except 分句可以在括号中列出多个异常的名字，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{k}{except} \PYG{p}{(}\PYG{n+ne}{RuntimeError}\PYG{p}{,} \PYG{n+ne}{TypeError}\PYG{p}{,} \PYG{n+ne}{NameError}\PYG{p}{)}\PYG{p}{:}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}     \PYG{k}{pass}
\end{Verbatim}

最后一个 except 分句可以省略异常名称，以作为通配符使用。你需要慎用此法，
因为它很容易就隐藏了一个实际的程序错误！可以使用这种方法打印一条错误信息，然后重新抛出异常（允许调用者处理这个异常):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{myfile.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{OSError} \PYG{k}{as} \PYG{n}{err}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OS error: \PYGZob{}0\PYGZcb{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{err}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not convert data to an integer.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Unexpected error:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{exc\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{raise}
\end{Verbatim}

\href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} ... \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 语句可以带有一个 \emph{else 分句}，该分句只能出现在所有 except 分句之后。
当 try 语句没有抛出异常，并需要执行一些代码时，可以使用这个分句。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{arg} \PYG{o+ow}{in} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{except} \PYG{n+ne}{IOError}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cannot open}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{arg}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{arg}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{has}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lines}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

使用 \href{https://docs.python.org/3/reference/compound\_stmts.html\#else}{else} 分句比在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 分句中附加代码要好，
因为这样可以避免 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} ... \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 意外的捕获本来不属于它们范围内的代码所抛出的异常。

发生异常时，可能会有一个附属值，作为异常的 \emph{参数} 存在。这个参数是否存在、是什么类型，依赖于异常的类型。

在异常名（列表）之后，也可以为 except 分句指定一个变量。这个变量绑定于一个异常实例，
它存储在 \code{instance.args} 的参数中。为了方便起见，异常实例定义了 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_str\_\_}{\_\_str\_\_()} 方法，
这样就可以直接调用对象来打印参数而不必引用 \code{.args}。另一种做法是， 在抛出异常之前进行实例化然后给实例添加一些指定的属性。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eggs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{inst}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{inst}\PYG{p}{)}\PYG{p}{)}    \PYG{c}{\PYGZsh{} the exception instance}
\PYG{g+gp}{... }   \PYG{k}{print}\PYG{p}{(}\PYG{n}{inst}\PYG{o}{.}\PYG{n}{args}\PYG{p}{)}     \PYG{c}{\PYGZsh{} arguments stored in .args}
\PYG{g+gp}{... }   \PYG{k}{print}\PYG{p}{(}\PYG{n}{inst}\PYG{p}{)}          \PYG{c}{\PYGZsh{} \PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{} allows args to be printed directly,}
\PYG{g+gp}{... }                        \PYG{c}{\PYGZsh{} but may be overridden in exception subclasses}
\PYG{g+gp}{... }   \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{inst}\PYG{o}{.}\PYG{n}{args}     \PYG{c}{\PYGZsh{} unpack args}
\PYG{g+gp}{... }   \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\PYG{g+gp}{... }   \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}Exception\PYGZsq{}\PYGZgt{}}
\PYG{g+go}{(\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}eggs\PYGZsq{})}
\PYG{g+go}{(\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}eggs\PYGZsq{})}
\PYG{g+go}{x = spam}
\PYG{g+go}{y = eggs}
\end{Verbatim}

对于那些未处理的异常，如果它们带有参数，那么就会被作为异常信息的最后部分（“详情”）打印出来。

异常处理器不仅仅处理那些在 try 分句中立刻发生的异常，也会处理那些 try 分句中调用的函数中内部发生的异常。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{this\PYGZus{}fails}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{0}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{this\PYGZus{}fails}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{except} \PYG{n+ne}{ZeroDivisionError} \PYG{k}{as} \PYG{n}{err}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Handling run\PYGZhy{}time error:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{err}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{Handling run\PYGZhy{}time error: int division or modulo by zero}
\end{Verbatim}


\section{抛出异常}
\label{errors:tut-raising}\label{errors:id5}
\href{https://docs.python.org/3/reference/simple\_stmts.html\#raise}{raise} 语句允许程序员强制抛出一个指定的异常。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{raise} \PYG{n+ne}{NameError}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HiThere}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{NameError}: \PYG{n}{HiThere}
\end{Verbatim}

\href{https://docs.python.org/3/reference/simple\_stmts.html\#raise}{raise} 的唯一参数指定了要抛出的异常。它必需是一个异常实例或异常类（继承自 \href{https://docs.python.org/3/library/exceptions.html\#Exception}{Exception} 的类）。

如果你需要明确一个异常是否抛出，但又不想处理它，\href{https://docs.python.org/3/reference/simple\_stmts.html\#raise}{raise} 语句可以让你很简单的重新抛出这个异常:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{raise} \PYG{n+ne}{NameError}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HiThere}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{except} \PYG{n+ne}{NameError}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{An exception flew by!}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{raise}
\PYG{g+gp}{...}
\PYG{g+go}{An exception flew by!}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{2}, in \PYG{n}{?}
\PYG{g+gr}{NameError}: \PYG{n}{HiThere}
\end{Verbatim}


\section{用户自定义异常}
\label{errors:tut-userexceptions}\label{errors:id6}
在程序中可以通过创建新的异常类型来命名自己的异常（Python 类的内容请参见 {\hyperref[classes:tut-classes]{\emph{\DUspan{}{类}}}} (\autopageref*{classes:tut-classes}) ）。
异常类通常应该直接或间接的从 \href{https://docs.python.org/3/library/exceptions.html\#Exception}{Exception} 类派生，例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{MyError}\PYG{p}{(}\PYG{n+ne}{Exception}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value} \PYG{o}{=} \PYG{n}{value}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{return} \PYG{n+nb}{repr}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{raise} \PYG{n}{MyError}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{k}{except} \PYG{n}{MyError} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{My exception occurred, value:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{e}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{My exception occurred, value: 4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{raise} \PYG{n}{MyError}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{oops!}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
\PYG{g+gr}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}.MyError}: \PYG{n}{\PYGZsq{}oops!\PYGZsq{}}
\end{Verbatim}

在这个例子中，\href{https://docs.python.org/3/library/exceptions.html\#Exception}{Exception} 默认的 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_init\_\_}{\_\_init\_\_()} 方法被覆盖。
新的 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_init\_\_}{\_\_init\_\_()} 方法只是简单的创建 \emph{value} 属性。
这样就替换了原来创建 \emph{args} 属性的方式。

异常类中可以定义任何其它类中可以定义的东西，但是通常为了保持简单，只在其中加入几个属性信息，
以供异常处理句柄提取。如果一个新创建的模块中需要抛出几种不同的错误时，一个通常的作法是为该模块定义一个异常基类，
然后针对不同的错误类型派生出对应的异常子类:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Error}\PYG{p}{(}\PYG{n+ne}{Exception}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Base class for exceptions in this module.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{pass}

\PYG{k}{class} \PYG{n+nc}{InputError}\PYG{p}{(}\PYG{n}{Error}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Exception raised for errors in the input.}

\PYG{l+s+sd}{    Attributes:}
\PYG{l+s+sd}{        expression \PYGZhy{}\PYGZhy{} input expression in which the error occurred}
\PYG{l+s+sd}{        message \PYGZhy{}\PYGZhy{} explanation of the error}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{expression}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{expression} \PYG{o}{=} \PYG{n}{expression}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{message} \PYG{o}{=} \PYG{n}{message}

\PYG{k}{class} \PYG{n+nc}{TransitionError}\PYG{p}{(}\PYG{n}{Error}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Raised when an operation attempts a state transition that\PYGZsq{}s not}
\PYG{l+s+sd}{    allowed.}

\PYG{l+s+sd}{    Attributes:}
\PYG{l+s+sd}{        previous \PYGZhy{}\PYGZhy{} state at beginning of transition}
\PYG{l+s+sd}{        next \PYGZhy{}\PYGZhy{} attempted new state}
\PYG{l+s+sd}{        message \PYGZhy{}\PYGZhy{} explanation of why the specific transition is not allowed}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{previous}\PYG{p}{,} \PYG{n+nb}{next}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{previous} \PYG{o}{=} \PYG{n}{previous}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{next} \PYG{o}{=} \PYG{n+nb}{next}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{message} \PYG{o}{=} \PYG{n}{message}
\end{Verbatim}

与标准异常相似，大多数异常的命名都以 “Error” 结尾。

很多标准模块中都定义了自己的异常，用以报告在他们所定义的函数中可能发生的错误。
关于类的进一步信息请参见 {\hyperref[classes:tut-classes]{\emph{\DUspan{}{类}}}} (\autopageref*{classes:tut-classes}) 一章。


\section{定义清理行为}
\label{errors:id8}\label{errors:tut-cleanup}
\href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句还有另一个可选的分句，目的在于定义在任何情况下都一定要执行的功能。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{raise} \PYG{n+ne}{KeyboardInterrupt}
\PYG{g+gp}{... }\PYG{k}{finally}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Goodbye, world!}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{Goodbye, world!}
\PYG{n+nc}{KeyboardInterrupt}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{2}, in \PYG{n}{?}
\end{Verbatim}

不管有没有发生异常，\emph{finally 分句} 在程序离开 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 后都一定会被执行。当 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句中
发生了未被 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 捕获的异常（或者它发生在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 或 \href{https://docs.python.org/3/reference/compound\_stmts.html\#else}{else} 分句中）时，
在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#finally}{finally} 分句执行完后它会被重新抛出。 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 语句经由 \href{https://docs.python.org/3/reference/simple\_stmts.html\#break}{break} ，\href{https://docs.python.org/3/reference/simple\_stmts.html\#continue}{continue} 或 \href{https://docs.python.org/3/reference/simple\_stmts.html\#return}{return} 语句
退出也一样会执行 \href{https://docs.python.org/3/reference/compound\_stmts.html\#finally}{finally} 分句。以下是一个更复杂些的例子:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{def} \PYG{n+nf}{divide}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{try}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n}{result} \PYG{o}{=} \PYG{n}{x} \PYG{o}{/} \PYG{n}{y}
\PYG{g+gp}{... }    \PYG{k}{except} \PYG{n+ne}{ZeroDivisionError}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{division by zero!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{else}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{result is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{result}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{finally}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{executing finally clause}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{result is 2}
\PYG{g+go}{executing finally clause}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{divide}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{division by zero!}
\PYG{g+go}{executing finally clause}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{divide}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{executing finally clause}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{3}, in \PYG{n}{divide}
\PYG{g+gr}{TypeError}: \PYG{n}{unsupported operand type(s) for /: \PYGZsq{}str\PYGZsq{} and \PYGZsq{}str\PYGZsq{}}
\end{Verbatim}

如你所见， \href{https://docs.python.org/3/reference/compound\_stmts.html\#finally}{finally} 分句在任何情况下都会执行。\href{https://docs.python.org/3/library/exceptions.html\#TypeError}{TypeError} 在两个字符串相除的时候抛出，未被 except 分句捕获，
因此在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#finally}{finally} 分句执行完毕后重新抛出。

在真实的应用程序中，\href{https://docs.python.org/3/reference/compound\_stmts.html\#finally}{finally} 分句用于释放外部资源（例如文件或网络连接），无论它们的使用过程中是否出错。


\section{预定义清理行为}
\label{errors:tut-cleanup-with}\label{errors:id9}
有些对象定义了标准的清理行为，无论对象操作是否成功，不再需要该对象的时候就会起作用。
以下示例尝试打开文件并把内容打印到屏幕上。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myfile.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{Verbatim}

这段代码的问题在于在代码执行完后没有立即关闭打开的文件。这在简单的脚本里没什么，
但是大型应用程序就会出问题。\href{https://docs.python.org/3/reference/compound\_stmts.html\#with}{with} 语句能够确保像文件这样的对象总能及时准确地进行清理。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myfile.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{Verbatim}

语句执行后，文件 \emph{f} 总会被关闭，即使是在处理文件中的数据时出错也一样。
其它对象是否提供了预定义的清理行为要查看它们的文档。


\chapter{类}
\label{classes:with}\label{classes:id1}\label{classes::doc}\label{classes:tut-classes}
与其他语言相比 Python 的类机制只是增加了一少部分的新语法和语义。
它是 C++ 和 Modula-3 语言类机制的混合体。 Python 类提供了面向对象编程的所有标准属性: 类继承机制允许多重继承
, 派生类可以重写基类中的任何方法，并且一个方法可以调用基类中与它名字相同的方法。对象可以包含任意数量和类型数据。
与模块一样，类也加入了 Python 的动态性质: 他们可以在运行时创建，创建好了之后可以在以后修改。

用 C++ 术语来讲，所有的类成员（包括数据成员）都是公有（ \emph{public} ）的（其它情况见下文 {\hyperref[classes:tut-private]{\emph{\DUspan{}{私有变量}}}} (\autopageref*{classes:tut-private})），
所有的成员函数都是虚（ \emph{virtual} ）的。用 Modula-3 的术语来讲，在成员方法中没有简便的方式引用对象的成员：
方法函数在定义时需要以引用的对象做为第一个参数，调用时则会隐式引用该对象。像在 Smalltalk 中一样，类也是对象。
这就提供了导入和重命名的语义。不像 C++ 和 Modula-3 中那样，大多数带有特殊语法的内置操作符（算法运算符、下标等）
都可以针对类的需要进行重新定义。

在讨论类时，没有得到足够多的共识的术语，我会偶尔从 Smalltalk 和 C++ 中借用一些。
我比较喜欢用 Modula-3 的用语，因为比起 C++，Python 的面向对象语法更像它，但是我想很少有读者听过这个。


\section{术语相关}
\label{classes:tut-object}\label{classes:id2}
对象有其特性，并且多个名称（在多个作用于中）可以绑定在同一个对象上。在其它语言中被称为别名。
在初次接触 Python 的时候不容易理解，在处理不可变类型（数字，字符串，元组）时你可以放心的忽略它们。
但是，在调用列表、字典这类可变对象，或者大多数程序外部类型（文件，窗体等）描述实体时，
别名对 Python 代码的语义便具有影响。这通常有助于程序的优化，
因为在某些方面别名表现的就像是指针。例如，传递一个对象是很高效的，因为你仅仅给了使用者一个指针而已
并且如果一个函数改变了作为参数传过来的对象时，调用者能够看到它的变化。--- 这消除了像 Pascal
语言那样需要两种不同的参数传递机制。


\section{Python 作用域和命名空间}
\label{classes:tut-scopes}\label{classes:python}
在介绍类之前，我首先介绍一些有关 Python 作用域的规则。类的定义非常巧妙的运用了命名空间，
要完全理解接下来的知识，需要先理解作用域和命名空间的工作原理。另外，这一切的知识对于任何高级 Python 程序员都非常有用。

让我们从一些定义说起。

\emph{命名空间} 是从命名到对象的映射。当前命名空间主要是通过 Python 字典实现的，
不过通常不关心具体的实现方式（除非出于性能考虑），以后也有可能会改变其实现方式。
命名空间的例子包括：内置命名（像 \href{https://docs.python.org/3/library/functions.html\#abs}{abs()} 这样的函数，以及内置异常名）集，
模块中的全局命名，函数调用中的局部命名。某种意义上讲对象的属性集也是一个命名空间。
关于命名空间需要了解的一件很重要的事就是不同命名空间中的命名没有任何联系，
例如两个不同的模块可能都会定义一个名为 \code{maximize} 的函数但不会发生混淆 --- 用户必须以模块名为前缀来引用它们。

顺便提一句，我称 Python 中任何一个“.”之后的命名为 \emph{属性} --- 例如，表达式 \code{z.real} 中的 \code{real} 是对象 \code{z} 的一个属性。
严格来讲，从模块中引用命名是属性引用：表达式 \code{modname.funcname} 中，\code{modname} 是一个模块对象，
\code{funcname} 是它的一个属性。因此，模块的属性和模块中的全局命名有直接的映射关系：它们共享同一个命名空间！\footnote{
有一个例外。模块对象有一个隐秘的只读属性，名为 \code{\_\_dict\_\_} ，它返回用于实现模块命名空间的字典，
命名 \code{\_\_dict\_\_}  是一个属性而非全局命名。显然，使用它违反了命名空间实现的抽象原则，应该被严格限制于调试中。
}

属性可以是只读的或是可写的。可写的情况下，可以对属性赋值。你可以这样做： \code{modname.the\_answer = 42} 。
可写的属性也可以用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#del}{del} 语句删除。例如： \code{del modname.the\_answer} 会从 \code{modname} 对象中删除 \code{the\_answer} 属性。

不同的命名空间在不同的时刻创建，有不同的生命周期。包含内置命名的命名空间在 Python 解释器启动时创建，会一直保留，不被删除。
模块的全局命名空间在模块定义被读入时创建，通常，模块命名空间也会一直保存到解释器退出。
由解释器在最高层调用的执行语句，不管它是从脚本文件中读入还是来自交互式输入，
都是 \href{https://docs.python.org/3/library/\_\_main\_\_.html\#module-\_\_main\_\_}{\_\_main\_\_} 模块的一部分，
所以它们也拥有自己的命名空间（内置命名事实上也同样被包含在一个模块中，它被称作 \href{https://docs.python.org/3/library/builtins.html\#module-builtins}{builtins} ）。

当调用函数时，就会为它创建一个局部命名空间，并且在函数返回或抛出一个并没有在函数内部处理的异常时被删除。
（实际上，用遗忘来形容到底发生了什么更为贴切。）当然，每个递归调用都有自己的局部命名空间。

\emph{作用域} 就是一个 Python 程序可以直接访问命名空间的正文区域。这里的 ``直接访问'' 的意思是不受限制的引用一个命名
会尝试在命名空间内查找这个命名。

尽管作用域是静态定义的，在使用时他们都是动态的。每次执行时，至少有三个嵌套的作用域，它们的命名空间可以直接访问：
\begin{itemize}
\item {} 
最里边的作用域，将首先被搜索到，它包含了局部命名。

\item {} 
封闭函数的作用域，将从最近的封闭作用域开始搜索，其中包括非局部命名也可以是非全局的命名。

\item {} 
接下来的作用域包含当前模块的全局命名

\item {} 
最外层的作用域（最后搜索）是包含内置命名的命名空间

\end{itemize}

如果一个命名声明为全局的，那么对它的所有引用和赋值将直接作用于中间作用域，它包含该模块的全局命名。
如果要重新绑定最里层作用域之外的变量，可以使用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#nonlocal}{nonlocal} 语句；如果不声明为 nonlocal，
这些变量将是只读的（对这样的变量赋值会在最里面的作用域创建一个新的局部变量，外部具有相同命名的那个变量不会改变）。

通常，局部作用域引用当前函数的命名。在函数之外，局部作用域与全局作用域引用同一命名空间：模块命名空间。
类定义也是局部作用域中的另一个命名空间。

重要的是作用域决定于源程序的意义：一个定义于某模块中的函数，无论这个函数在什么位置或者使用什么别名被调用的
它的全局作用域是该模块的命名空间，了解这一点非常重要。
另一方面，命名的实际搜索过程是动态的，是在运行时确定的 --- 然而，语言未来可能更倾向于静态命名解析，也就是在
“编译”时确定，因此不要依赖于动态解析！（事实上，局部变量已经是静态确定的。）

Python 的一个特别之处在于：如果没有使用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 语法，其赋值操作总是在最里层的作用域。
赋值不会复制数据，只是将命名绑定到对象。删除也是如此：\code{del x} 只是从局部作用域的命名空间中删除命名 \code{x} 。
事实上，所有引入新命名的操作都作用于局部作用域。特别是， \href{https://docs.python.org/3/reference/simple\_stmts.html\#import}{import} 语句和函数定义
会将模块名或函数绑定于局部作用域上（可以使用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 语句将变量引入到全局作用域）。

\href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 语句用以指明某个特定的变量为全局作用域，并重新绑定它。\href{https://docs.python.org/3/reference/simple\_stmts.html\#nonlocal}{nonlocal} 语句用以
指明某个特定的变量为封闭作用域，并需要重新绑定它。


\subsection{作用域和命名空间示例}
\label{classes:id4}\label{classes:tut-scopeexample}
以下是一个示例，演示了如何引用不同作用域和命名空间，以及 \href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 和 \href{https://docs.python.org/3/reference/simple\_stmts.html\#nonlocal}{nonlocal} 如何影响变量绑定:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{scope\PYGZus{}test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{do\PYGZus{}local}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{spam} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{local spam}\PYG{l+s}{\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf}{do\PYGZus{}nonlocal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{nonlocal} \PYG{n}{spam}
        \PYG{n}{spam} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nonlocal spam}\PYG{l+s}{\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf}{do\PYGZus{}global}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{global} \PYG{n}{spam}
        \PYG{n}{spam} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{global spam}\PYG{l+s}{\PYGZdq{}}
    \PYG{n}{spam} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test spam}\PYG{l+s}{\PYGZdq{}}
    \PYG{n}{do\PYGZus{}local}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{After local assignment:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{spam}\PYG{p}{)}
    \PYG{n}{do\PYGZus{}nonlocal}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{After nonlocal assignment:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{spam}\PYG{p}{)}
    \PYG{n}{do\PYGZus{}global}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{After global assignment:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{spam}\PYG{p}{)}

\PYG{n}{scope\PYGZus{}test}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In global scope:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{spam}\PYG{p}{)}
\end{Verbatim}

以上示例代码的输出为:

\begin{Verbatim}[commandchars=\\\{\}]
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
\end{Verbatim}

注意：\emph{local} 赋值语句是无法改变 \emph{scope\_test} 的 \emph{spam} 绑定。\href{https://docs.python.org/3/reference/simple\_stmts.html\#nonlocal}{nonlocal} 赋值语句改变了 \emph{scope\_test} 的 \emph{spam} 绑定，
并且 \href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 赋值语句从模块级改变了 spam 绑定。

你也可以看到在 \href{https://docs.python.org/3/reference/simple\_stmts.html\#global}{global} 赋值语句之前对 \emph{spam} 是没有预先绑定的。


\section{初识类}
\label{classes:tut-firstclasses}\label{classes:id5}
类引入了一些新语法：三种新的对象类型和一些新的语义。


\subsection{类定义语法}
\label{classes:tut-classdefinition}\label{classes:id6}
类定义最简单的形式如下:

\begin{Verbatim}[commandchars=\\\{\}]
class ClassName:
    \PYGZlt{}statement\PYGZhy{}1\PYGZgt{}
    .
    .
    .
    \PYGZlt{}statement\PYGZhy{}N\PYGZgt{}
\end{Verbatim}

类的定义就像函数定义（ \href{https://docs.python.org/3/reference/compound\_stmts.html\#def}{def} 语句），要先执行才能生效。（你当然可以把它放进 \href{https://docs.python.org/3/reference/compound\_stmts.html\#if}{if} 语句的某一分支，或者一个函数的内部。）

习惯上，类定义语句的内容通常是函数定义，不过其它语句也可以，有时会很有用 --- 后面我们再回过头来讨论。
类中的函数定义通常包括了一个特殊形式的参数列表，用于方法调用约定 --- 同样我们在后面讨论这些。

进入类定义部分后，会创建出一个新的命名空间，作为局部作用域。因此，所有的赋值成为这个新命名空间的局部变量。
特别的是，在这里函数定义在命名上绑定为一个新函数。

类定义完成时（正常退出），就创建了一个 \emph{类对象}。基本上它是对类定义创建的命名空间进行了一个包装；
我们在下一节进一步学习类对象的知识。原始的局部作用域（类定义引入之前生效的那个）得到恢复，
类对象在这里是绑定到类定义头部的类名（例子中是 \code{ClassName} ）。


\subsection{类对象}
\label{classes:tut-classobjects}\label{classes:id7}
类对象支持两种操作：属性引用和实例化。

\emph{属性引用} 使用和 Python 中所有的属性引用一样的标准语法：\code{obj.name}。
类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MyClass}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A simple example class\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{12345}
    \PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

那么 \code{MyClass.i} 和 \code{MyClass.f} 是有效的属性引用，分别返回一个整数和一个方法对象。
也可以对类属性赋值，你可以通过给 \code{MyClass.i} 赋值来修改它。 \code{\_\_doc\_\_} 也是一个有效的属性，
返回类的文档字符串：\code{"A simple example class"}。

类的 \emph{实例化} 使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。例如（假设沿用前面的类）:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

以上创建了一个新的类 \emph{实例} 并将该对象赋给局部变量 \code{x}。

这个实例化操作（“调用”一个类对象）创建了一个空的对象。很多类都倾向于将对象创建为有初始状态的。
因此类可能会定义一个名为 \code{\_\_init\_\_()} 的特殊方法，像下面这样:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\end{Verbatim}

类定义了 \code{\_\_init\_\_()} 方法的话，类的实例化操作会自动为新创建的类实例调用 \code{\_\_init\_\_()} 方法。
所以在下例中，可以这样创建一个新的实例:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{MyClass}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

当然，出于灵活性的需要，\code{\_\_init\_\_()} 方法可以有参数。事实上，
参数通过 \code{\_\_init\_\_()} 传递到类的实例化操作上。例如，

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{Complex}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{realpart}\PYG{p}{,} \PYG{n}{imagpart}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{r} \PYG{o}{=} \PYG{n}{realpart}
\PYG{g+gp}{... }        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{i} \PYG{o}{=} \PYG{n}{imagpart}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{n}{Complex}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{r}\PYG{p}{,} \PYG{n}{x}\PYG{o}{.}\PYG{n}{i}
\PYG{g+go}{(3.0, \PYGZhy{}4.5)}
\end{Verbatim}


\subsection{实例对象}
\label{classes:tut-instanceobjects}\label{classes:id8}
现在我们可以用实例对象做什么？实例对象唯一可用的操作就是属性引用。有两种有效的属性名。

\emph{数据属性} 相当于 Smalltalk 中的“实例变量”或 C++ 中的“数据成员”。和局部变量一样，数据属性不需要声明，
第一次使用时它们就会生成。例如，如果 \code{x} 是前面创建的 \code{MyClass} 实例，下面这段代码会在不保留堆栈信息的情况下
打印出 16

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{o}{.}\PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{while} \PYG{n}{x}\PYG{o}{.}\PYG{n}{counter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{n}{x}\PYG{o}{.}\PYG{n}{counter} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{counter} \PYG{o}{*} \PYG{l+m+mi}{2}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{counter}\PYG{p}{)}
\PYG{k}{del} \PYG{n}{x}\PYG{o}{.}\PYG{n}{counter}
\end{Verbatim}

另一种为实例对象所接受的引用属性是 \emph{方法}。方法是“属于”一个对象的函数。（在 Python 中，
方法不止是类实例所独有：其它类型的对象也可有方法。例如，链表对象有 append，insert，remove，sort 等等方法。
然而，在后面的介绍中，除非特别说明，我们提到的方法特指类方法）

\index{对象!method}\index{method!对象}
实例对象的有效名称依赖于它的类。按照定义，类中所有（用户定义）的函数对象对应它的实例中的方法。
所以在我们的例子中，\code{x.f} 是一个有效的方法引用，因为 \code{MyClass.f} 是一个函数。但 \code{x.i} 不是，
因为 \code{MyClass.i} 不是函数。不过 \code{x.f} 和 \code{MyClass.f} 不同，它是一个 \emph{方法对象} ，不是一个函数对象。


\subsection{方法对象}
\label{classes:tut-methodobjects}\label{classes:id9}
通常，方法通过右绑定方式调用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{o}{.}\PYG{n}{f}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

在 \code{MyClass} 示例中，这会返回字符串 \code{'hello world'}。然而，
也不是一定要直接调用方法。 \code{x.f} 是一个方法对象，它可以存储起来供以后调用。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{xf} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{f}
\PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{xf}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

会不断的打印 \code{hello world}。

调用方法时发生了什么？你可能注意到调用 \code{x.f()} 时没有用到上面的参数，
尽管在 \code{f()} 的函数定义中指明了一个参数。这个参数怎么了？事实上如果函数调用中缺少参数，Python 会
抛出异常 --- 即使这个参数实际上没什么用...

那么，你可能已经猜到了答案：方法的特别之处在于实例对象作为函数的第一个参数传给了函数。
在我们的例子中，调用 \code{x.f()} 相当于 \code{MyClass.f(x)} 。通常，以 \emph{n} 个参数的列表去调用一个方法
就相当于将方法的对象插入到参数列表的最前面后，以这个列表去调用相应的函数。

如果你还是不理解方法的工作原理，了解一下它的实现也许有帮助。引用非数据属性的实例属性时，
会搜索它的类。如果这个命名确认为一个有效的函数对象，就会将实例对象和函数对象封装进一个抽象对象：
这就是方法对象。以一个参数列表调用方法对象时，实例对象和这个参数列表将构造一个新的参数列表，
然后函数对象调用这个新的参数列表。


\subsection{类和实例变量}
\label{classes:tut-class-and-instance-variables}\label{classes:id10}
一般来说，对每一个实例，实例变量的数据是唯一的，类变量的属性和方法将被所有的该类的实例共享:

\begin{Verbatim}[commandchars=\\\{\}]
class Dog:

    kind = \PYGZsq{}canine\PYGZsq{}         \PYGZsh{} class variable shared by all instances

    def \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self, name):
        self.name = name    \PYGZsh{} instance variable unique to each instance

\PYGZgt{}\PYGZgt{}\PYGZgt{} d = Dog(\PYGZsq{}Fido\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} e = Dog(\PYGZsq{}Buddy\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} d.kind                  \PYGZsh{} shared by all dogs
\PYGZsq{}canine\PYGZsq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} e.kind                  \PYGZsh{} shared by all dogs
\PYGZsq{}canine\PYGZsq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} d.name                  \PYGZsh{} unique to d
\PYGZsq{}Fido\PYGZsq{}
\PYGZgt{}\PYGZgt{}\PYGZgt{} e.name                  \PYGZsh{} unique to e
\PYGZsq{}Buddy\PYGZsq{}
\end{Verbatim}

正如在 {\hyperref[classes:tut-object]{\emph{\DUspan{}{术语相关}}}} (\autopageref*{classes:tut-object}) 讨论的， \href{https://docs.python.org/3/glossary.html\#term-mutable}{可变} 对象，像列表和字典的共享数据可能带来意外的影响。
例如，下面代码中的 \emph{tricks} 列表不应该用作类变量，因为所有的 \emph{Dog}  实例将共享同一个列表:

\begin{Verbatim}[commandchars=\\\{\}]
class Dog:

    tricks = []             \PYGZsh{} mistaken use of a class variable

    def \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self, name):
        self.name = name

    def add\PYGZus{}trick(self, trick):
        self.tricks.append(trick)

\PYGZgt{}\PYGZgt{}\PYGZgt{} d = Dog(\PYGZsq{}Fido\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} e = Dog(\PYGZsq{}Buddy\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} d.add\PYGZus{}trick(\PYGZsq{}roll over\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} e.add\PYGZus{}trick(\PYGZsq{}play dead\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} d.tricks                \PYGZsh{} unexpectedly shared by all dogs
[\PYGZsq{}roll over\PYGZsq{}, \PYGZsq{}play dead\PYGZsq{}]
\end{Verbatim}

这个类的正确设计应该使用一个实例变量:

\begin{Verbatim}[commandchars=\\\{\}]
class Dog:

    def \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self, name):
        self.name = name
        self.tricks = []    \PYGZsh{} creates a new empty list for each dog

    def add\PYGZus{}trick(self, trick):
        self.tricks.append(trick)

\PYGZgt{}\PYGZgt{}\PYGZgt{} d = Dog(\PYGZsq{}Fido\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} e = Dog(\PYGZsq{}Buddy\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} d.add\PYGZus{}trick(\PYGZsq{}roll over\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} e.add\PYGZus{}trick(\PYGZsq{}play dead\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} d.tricks
[\PYGZsq{}roll over\PYGZsq{}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} e.tricks
[\PYGZsq{}play dead\PYGZsq{}]
\end{Verbatim}


\section{一些说明}
\label{classes:tut-remarks}\label{classes:id11}
数据属性会覆盖同名的方法属性。为了避免意外的名称冲突，这在大型程序中是极难发现的 Bug，
使用一些约定来减少冲突的机会是明智的。可能的约定包括：大写方法名称的首字母，使用一个唯一的小字符串
（也许只是一个下划线）作为数据属性名称的前缀，或者方法使用动词而数据属性使用名词。

数据属性可以被方法引用，也可以由一个对象的普通用户（客户）使用。换句话说，
类不能用来实现纯粹的虚数据类型。事实上，Python 中无法实现强制隐藏数据 --- 一切基于约定
（如果需要，使用 C 编写的 Python 实现可以完全隐藏实现细节并控制对象的访问。这可以用来通过 C 语言扩展 Python）。

用户应该谨慎的使用数据属性 --- 用户可能通过混入他们的数据属性从而使那些由方法维护的常量变得混乱。
注意：只要能避免冲突，客户可以向一个实例对象中添加他们自己的数据属性，而不会影响方法的正确性 --- 再次强调，
命名约定可以避免很多麻烦。

从方法内部引用数据属性（或其他方法）并没有快捷方式。我觉得这实际上增加了方法的可读性：
当浏览一个方法时，在局部变量和实例变量之间不会出现令人费解的情况。

一般，方法的第一个参数被命名为 \code{self}。这仅仅是一个约定：对 Python 而言，名称 \code{self} 绝对没有任何
特殊含义。（但是请注意：如果不遵循这个约定，对其他的 Python 程序员而言你的代码可读性就会变差，
而且有些 \emph{类查看器} 程序也可能是遵循此约定编写的。）

任何方法对象都可以作为类实例的属性方法。函数定义代码不一定非得定义在类中：
也可以将一个函数对象赋值给类中的一个局部变量。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Function defined outside the class}
\PYG{k}{def} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{C}\PYG{p}{:}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{f1}
    \PYG{k}{def} \PYG{n+nf}{g}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{g}
\end{Verbatim}

现在 \code{f}， \code{g} 和 \code{h} 都是类 \code{C} 的属性，引用的都是函数对象，因此它们都是 \code{C} 实例的方法 ---
\code{h} 严格等于 \code{g} 。要注意的是这种习惯通常只会迷惑程序的读者。

通过 \code{self} 参数的方法属性，方法可以调用其它的方法:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Bag}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{addtwice}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

方法可以像引用普通的函数那样引用全局命名。与方法关联的全局作用域是包含类定义的模块。
（类本身永远不会做为全局作用域使用。）尽管很少有理由在方法中使用全局数据，
全局作用域确有很多合法的用途：其一是方法可以调用导入全局作用域的函数和方法，
也可以调用定义在其中的类和函数。通常，包含此方法的类也会定义在这个全局作用域，
在下一节我们会了解为何一个方法要引用自己的类。

每个值都是一个对象，因此每个值都有一个 类( \emph{class} ) （也称它为 类型( \emph{type} ) ），它存储为 \code{object.\_\_class\_\_} 。


\section{继承}
\label{classes:tut-inheritance}\label{classes:id12}
当然，如果类不支持继承，那么这个语言的特性会让人很失望。派生类的定义如下所示:

\begin{Verbatim}[commandchars=\\\{\}]
class DerivedClassName(BaseClassName):
    \PYGZlt{}statement\PYGZhy{}1\PYGZgt{}
    .
    .
    .
    \PYGZlt{}statement\PYGZhy{}N\PYGZgt{}
\end{Verbatim}

命名 \code{BaseClassName} （示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，
基类定义在另一个模块中时这一点非常有用:

\begin{Verbatim}[commandchars=\\\{\}]
class DerivedClassName(modname.BaseClassName):
\end{Verbatim}

派生类定义的执行过程和基类是一样的。构造派生类对象时，就记住了基类。
这在解析属性引用的时候尤其有用：如果在类中找不到请求调用的属性，就搜索基类。
如果基类是由别的类派生而来，这个规则会递归的应用上去。

派生类的实例化没有什么特殊之处： \code{DerivedClassName()} 创建了一个新的类实例。
方法引用按如下规则解析：搜索对应的类属性，必要时沿基类链逐级搜索，如果找到了函数对象这个方法引用就是合法的。

派生类可能会覆盖其基类的方法。因为方法调用同一个对象中的其它方法时没有特权，基类的方法调用同一个基类的方法时，
可能实际上最终调用了派生类中的覆盖方法。（对于 C++ 程序员来说，Python 中的所有方法本质上都是 \code{虚} 方法。）

派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。
有一种简单的方法可以直接调用基类方法，只要调用： \code{BaseClassName.methodname(self, arguments)}。
有时这对于用户很有用。（要注意只有 \code{BaseClassName} 在同一全局作用域定义或导入时才能这样用。）

Python 有两个用于继承的函数：
\begin{itemize}
\item {} 
函数 \href{https://docs.python.org/3/library/functions.html\#isinstance}{isinstance()} 用于检查实例类型： \code{isinstance(obj, int)} 只有在 \code{obj.\_\_class\_\_} 是 \href{https://docs.python.org/3/library/functions.html\#int}{int} 或
其它从 \href{https://docs.python.org/3/library/functions.html\#int}{int} 继承来的类型时为真。

\item {} 
函数 \href{https://docs.python.org/3/library/functions.html\#issubclass}{issubclass()} 用于检查类继承： \code{issubclass(bool, int)} 为 \code{True}，因为 \href{https://docs.python.org/3/library/functions.html\#bool}{bool} 是 \href{https://docs.python.org/3/library/functions.html\#int}{int} 的子类。
然而， \code{issubclass(float, int)} 为 \code{False}，因为 \href{https://docs.python.org/3/library/functions.html\#float}{float} 不是 \href{https://docs.python.org/3/library/functions.html\#int}{int} 的子类。

\end{itemize}


\subsection{多继承}
\label{classes:tut-multiple}\label{classes:id13}
Python 同样有限的支持多继承形式。多继承的类定义形如下例:

\begin{Verbatim}[commandchars=\\\{\}]
class DerivedClassName(Base1, Base2, Base3):
    \PYGZlt{}statement\PYGZhy{}1\PYGZgt{}
    .
    .
    .
    \PYGZlt{}statement\PYGZhy{}N\PYGZgt{}
\end{Verbatim}

在大多数情况下，可以简单的认为搜索父类属性为深度优先，从左到右，
而不是在同一个类层次结构中搜索两次。因此，如果在 \code{DerivedClassName}
中没有找到某个属性，就会搜索 \code{Base1}，然后（递归的）搜索其基类，如果最终没有找到，就搜索 \code{Base2}，以此类推。

实际上，\href{https://docs.python.org/3/library/functions.html\#super}{super()} 可以动态的改变解析顺序。这个方式可见于其它的一些多继承语言，
类似 call-next-method，比单继承语言中的 super 更强大 。

动态调整顺序十分必要的，因为所有的多继承会有一到多个菱形关系（指有至少一个祖先类可以从子类经由多个继承路径到达）。
例如，所有的 new-style 类继承自 \href{https://docs.python.org/3/library/functions.html\#object}{object} ，所以任意的多继承总是会有多于一条继承路径到达 \href{https://docs.python.org/3/library/functions.html\#object}{object} 。

为了防止重复访问基类，通过动态的线性化算法，规定每个类都按从左到右的顺序搜索，每个祖先类只调用一次，
这是单调性的（意味着一个类被继承时不会影响它祖先的次序）。总算可以通过这种方式使得设计一个可靠并且可扩展的多继承类成为可能。
进一步的内容请参见 \href{http://www.python.org/download/releases/2.3/mro/}{http://www.python.org/download/releases/2.3/mro/} 。


\section{私有变量}
\label{classes:id14}\label{classes:tut-private}
只能从对像内部访问的“私有”实例变量，在 Python 中不存在。然而，也有一个变通的方法用于大多数 Python 代码：
以一个下划线开头的命名（例如 \code{\_spam} ）会被处理为 API 非公开部分（无论它是一个函数、方法或数据成员）。
它会被视为一个实现细节，无需公开。

由于有一个类私有成员存在的理由（即避免子类中定义的命名与之冲突），Python 提供了对这种结构的有限支持，
称为 \emph{name mangling} （命名混淆） 。任何形如 \code{\_\_spam} 的标识（前面至少两个下划线，后面至多一个），
被替代为 \code{\_classname\_\_spam} ，去掉前导下划线的 \code{classname} 即当前的类名。这种混淆跟标识符的语法位置无关
，只要求在类中定义。

命名混淆是有助于子类重写方法，而不会打破组内的方法调用。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Mapping}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{items\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}update}\PYG{p}{(}\PYG{n}{iterable}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{iterable}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{iterable}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{items\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}

    \PYG{n}{\PYGZus{}\PYGZus{}update} \PYG{o}{=} \PYG{n}{update}   \PYG{c}{\PYGZsh{} private copy of original update() method}

\PYG{k}{class} \PYG{n+nc}{MappingSubclass}\PYG{p}{(}\PYG{n}{Mapping}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{keys}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} provides new signature for update()}
        \PYG{c}{\PYGZsh{} but does not break \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}()}
        \PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{keys}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{items\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
\end{Verbatim}

需要注意的是混淆规则是被设计用来尽可能的避免冲突，而被认作为私有的变量仍然有可能被访问或修改。
在特定的场合它也是有用的，比如调试的时候。

要注意的是代码传入 \code{exec()}， \code{eval()} 时不考虑所调用的类的类名，视其为当前类，
这类似于 \code{global} 语句的效果，这种效果类似于受限制的代码一起被字节编码过。同样的限制
作用于 \code{getattr()}， \code{setattr()} 和 \code{delattr()}，就像直接引用 \code{\_\_dict\_\_} 一样。


\section{补充}
\label{classes:tut-odds}\label{classes:id15}
有时类似于 Pascal 中“记录（record）”或 C 中“结构（struct）”的数据类型很有用，
它将一组已命名的数据项绑定在一起。一个空的类定义可以很好的实现它:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Employee}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{n}{john} \PYG{o}{=} \PYG{n}{Employee}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Create an empty employee record}

\PYG{c}{\PYGZsh{} Fill the fields of the record}
\PYG{n}{john}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{John Doe}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{john}\PYG{o}{.}\PYG{n}{dept} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{computer lab}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{john}\PYG{o}{.}\PYG{n}{salary} \PYG{o}{=} \PYG{l+m+mi}{1000}
\end{Verbatim}

某一段 Python 代码需要一个特殊的抽象数据结构的话，通常可以传入一个类。
例如，如果你有一个用于从文件对象中格式化数据的函数，你可以定义一个带有 \code{read()} 和 \code{readline()} 方法的类，
它被用来从字符串缓冲区中读取数据，然后你将这个类作为参数传递给格式化数据的函数。

实例方法对象也有属性：\code{m.\_\_self\_\_} 是一个实例方法所属的对象，而 \code{m.\_\_func\_\_} 是这个方法对应的函数对象。


\section{异常也是类}
\label{classes:id16}\label{classes:tut-exceptionclasses}
用户自定义异常也可以是类。利用这个机制可以创建可扩展的异常体系。

以下是两种新的，有效的（语义上的）异常抛出形式，使用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#raise}{raise} 语句:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{raise} \PYG{n}{Class}

\PYG{k}{raise} \PYG{n}{Instance}
\end{Verbatim}

第一种形式中，\code{instance} 必须是 \href{https://docs.python.org/3/library/functions.html\#type}{type} 或其派生类的一个实例。第二种形式是以下形式的简写:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{raise} \PYG{n}{Class}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

发生的异常，其类型如果是 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 分句中列出的类，或者是其派生类，那么它们就是相符合的
（反过来说 --- 发生的异常其类型如果是异常分句中列出的类的基类，它们就不相符合）。
例如，以下代码会按顺序打印 B，C，D:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{B}\PYG{p}{(}\PYG{n+ne}{Exception}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}
\PYG{k}{class} \PYG{n+nc}{C}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}
\PYG{k}{class} \PYG{n+nc}{D}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{k}{for} \PYG{n}{cls} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{B}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{D}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{try}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n}{cls}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{except} \PYG{n}{D}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{except} \PYG{n}{C}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{except} \PYG{n}{B}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{B}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

要注意的是如果异常分句的顺序颠倒过来（ \code{execpt B} 在最前面），它就会打印 B，B，B --- 第一个匹配的异常被触发。

打印一个异常类的错误信息时，先打印类名，然后是一个空格、一个冒号，然后是用内置函数 \href{https://docs.python.org/3/library/stdtypes.html\#str}{str()} 将类转换得到的完整字符串。


\section{迭代器}
\label{classes:tut-iterators}\label{classes:id17}
现在你可能注意到大多数容器对象都可以用 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 遍历:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{element} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{element}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{element} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{element}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{123}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{char}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myfile.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

这种形式的访问清晰、简洁、方便。迭代器的用法在 Python 中普遍而且统一。
在内部， \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 语句在容器对象中调用 \href{https://docs.python.org/3/library/functions.html\#iter}{iter()} 。
该函数返回一个定义了 \href{https://docs.python.org/3/library/stdtypes.html\#iterator.\_\_next\_\_}{\_\_next\_\_()} 方法的迭代器对象，
它在容器中逐一访问元素。没有后续的元素时， \href{https://docs.python.org/3/library/stdtypes.html\#iterator.\_\_next\_\_}{\_\_next\_\_()}
抛出一个 \href{https://docs.python.org/3/library/exceptions.html\#StopIteration}{StopIteration} 异常通知 \href{https://docs.python.org/3/reference/compound\_stmts.html\#for}{for} 语句循环结束。你可以是用内建的 \href{https://docs.python.org/3/library/functions.html\#next}{next()}
函数调用 \href{https://docs.python.org/3/library/stdtypes.html\#iterator.\_\_next\_\_}{\_\_next\_\_()} 方法；以下是其工作原理的示例:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{it} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{it}
\PYG{g+go}{\PYGZlt{}iterator object at 0x00A1DB50\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}a\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}b\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}c\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{?}
    \PYG{n+nb}{next}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}
\PYG{g+gr}{StopIteration}
\end{Verbatim}

了解了迭代器协议的后台机制，就可以很容易的给自己的类添加迭代器行为。
定义一个 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_iter\_\_}{\_\_iter\_\_()} 方法，
使其返回一个带有 \href{https://docs.python.org/3/library/stdtypes.html\#iterator.\_\_next\_\_}{\_\_next\_\_()} 方法的对象。
如果这个类已经定义了 \href{https://docs.python.org/3/library/stdtypes.html\#iterator.\_\_next\_\_}{\_\_next\_\_()} ，
那么 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_iter\_\_}{\_\_iter\_\_()} 只需要返回 \code{self}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Reverse}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Iterator for looping over a sequence backwards.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}next\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{StopIteration}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rev} \PYG{o}{=} \PYG{n}{Reverse}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spam}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{iter}\PYG{p}{(}\PYG{n}{rev}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}.Reverse object at 0x00A1DB50\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{rev}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{char}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{m}
\PYG{g+go}{a}
\PYG{g+go}{p}
\PYG{g+go}{s}
\end{Verbatim}


\section{生成器}
\label{classes:tut-generators}\label{classes:id23}
\href{https://docs.python.org/3/glossary.html\#term-generator}{Generator} 是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，需要返回数据的时候使用 \href{https://docs.python.org/3/reference/simple\_stmts.html\#yield}{yield} 语句。
每次 \href{https://docs.python.org/3/library/functions.html\#next}{next()} 被调用时，生成器回复它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）。
以下示例演示了生成器可以被很简单的创建出来:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{index} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{data}\PYG{p}{[}\PYG{n}{index}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{reverse}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{golf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{n}{char}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{f}
\PYG{g+go}{l}
\PYG{g+go}{o}
\PYG{g+go}{g}
\end{Verbatim}

前一节中描述了基于类的迭代器，它能做的每一件事生成器也能作到。
因为自动创建了 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_iter\_\_}{\_\_iter\_\_()}
和 \href{https://docs.python.org/3/reference/expressions.html\#generator.\_\_next\_\_}{\_\_next\_\_()} 方法，生成器显得如此简洁。

另一个关键的功能在于两次调用之间，局部变量和执行状态都自动的保存下来。
这使函数更容易写，而且比使用 \code{self.index} 和 \code{self.data} 之类的方式更清晰。

除了自动创建方法和保存程序状态，当生成器结束时，会自动抛出 \href{https://docs.python.org/3/library/exceptions.html\#StopIteration}{StopIteration}  异常。
综上所述，这些功能使得编写一个迭代器就像编写一个常规的方法一样简单。


\section{生成器表达式}
\label{classes:tut-genexps}\label{classes:id26}
一些简单的生成器可以像编写表达式那样简洁，它的语法跟列表解析很像，只不过将中括号替换成了括号。
这些表达式是为闭包函数使用生成器而设计的。生成器表达式比完整的生成器定义更简洁，但是没有那么多变，
而且它比列表解析更省内存。

例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}                 \PYG{c}{\PYGZsh{} sum of squares}
\PYG{g+go}{285}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{xvec} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{yvec} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{y} \PYG{k}{for} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{xvec}\PYG{p}{,} \PYG{n}{yvec}\PYG{p}{)}\PYG{p}{)}         \PYG{c}{\PYGZsh{} dot product}
\PYG{g+go}{260}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{sin}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sine\PYGZus{}table} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{x}\PYG{p}{:} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{180}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{)}\PYG{p}{\PYGZcb{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{unique\PYGZus{}words} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{word}  \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{page}  \PYG{k}{for} \PYG{n}{word} \PYG{o+ow}{in} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{valedictorian} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{(}\PYG{n}{student}\PYG{o}{.}\PYG{n}{gpa}\PYG{p}{,} \PYG{n}{student}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)} \PYG{k}{for} \PYG{n}{student} \PYG{o+ow}{in} \PYG{n}{graduates}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{golf}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}f\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{}g\PYGZsq{}]}
\end{Verbatim}


\chapter{Python 标准库概览}
\label{stdlib:id31}\label{stdlib:tut-brieftour}\label{stdlib:python}\label{stdlib::doc}

\section{操作系统接口}
\label{stdlib:id1}\label{stdlib:tut-os-interface}
\href{https://docs.python.org/3/library/os.html\#module-os}{os} 模块提供了很多与操作系统交互的函数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{(}\PYG{p}{)}      \PYG{c}{\PYGZsh{} Return the current working directory}
\PYG{g+go}{\PYGZsq{}C:\PYGZbs{}\PYGZbs{}Python36\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{os}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/server/accesslogs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}   \PYG{c}{\PYGZsh{} Change current working directory}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mkdir today}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}   \PYG{c}{\PYGZsh{} Run the command mkdir in the system shell}
\PYG{g+go}{0}
\end{Verbatim}

应该用 \code{import os} 风格而非 \code{from os import *}。这样可以保证随操作系统不同而
有所变化的 \href{https://docs.python.org/3/library/os.html\#os.open}{os.open()} 不会覆盖内置函数 \href{https://docs.python.org/3/library/functions.html\#open}{open()}。

\index{內置函数!help}\index{help!內置函数}
在使用一些像 \href{https://docs.python.org/3/library/os.html\#module-os}{os} 这样的大型模块时内置的 \href{https://docs.python.org/3/library/functions.html\#dir}{dir()} 和 \href{https://docs.python.org/3/library/functions.html\#help}{help()} 函数非常有用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{os}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}returns a list of all module functions\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{os}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}returns an extensive manual page created from the module\PYGZsq{}s docstrings\PYGZgt{}}
\end{Verbatim}

针对日常的文件和目录管理任务，\href{https://docs.python.org/3/library/shutil.html\#module-shutil}{shutil} 模块提供了一个易于使用的高级接口:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{shutil}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copyfile}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data.db}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{archive.db}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}archive.db\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{shutil}\PYG{o}{.}\PYG{n}{move}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/build/executables}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{installdir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}installdir\PYGZsq{}}
\end{Verbatim}


\section{文件通配符}
\label{stdlib:id2}\label{stdlib:tut-file-wildcards}
\href{https://docs.python.org/3/library/glob.html\#module-glob}{glob} 模块提供了一个函数，用于使用通配符搜索目录，生成文件列表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{glob}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*.py}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}primes.py\PYGZsq{}, \PYGZsq{}random.py\PYGZsq{}, \PYGZsq{}quote.py\PYGZsq{}]}
\end{Verbatim}


\section{命令行参数}
\label{stdlib:tut-command-line-arguments}\label{stdlib:id3}
通常工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 \href{https://docs.python.org/3/library/sys.html\#module-sys}{sys} 模块的 \emph{argv} 变量。
例如在命令行中执行 \code{python demo.py one two three} 后可以得到以下输出结果:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}demo.py\PYGZsq{}, \PYGZsq{}one\PYGZsq{}, \PYGZsq{}two\PYGZsq{}, \PYGZsq{}three\PYGZsq{}]}
\end{Verbatim}

\href{https://docs.python.org/3/library/getopt.html\#module-getopt}{getopt} 模块使用 Unix \href{https://docs.python.org/3/library/getopt.html\#module-getopt}{getopt()} 函处理 \emph{sys.argv}。更多的复杂命令行处理由 \href{https://docs.python.org/3/library/argparse.html\#module-argparse}{argparse} 模块提供。


\section{错误输出重定向和程序终止}
\label{stdlib:tut-stderr}\label{stdlib:id4}
\href{https://docs.python.org/3/library/sys.html\#module-sys}{sys} 还有 \emph{stdin}， \emph{stdout} 和 \emph{stderr} 属性，即使在 \emph{stdout} 被重定向时，后者也可以用于显示警告和错误信息:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sys}\PYG{o}{.}\PYG{n}{stderr}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Warning, log file not found starting a new one}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{Warning, log file not found starting a new one}
\end{Verbatim}

大多脚本的定向终止都使用 \code{sys.exit()}。


\section{字符串正则匹配}
\label{stdlib:tut-string-pattern-matching}\label{stdlib:id5}
\href{https://docs.python.org/3/library/re.html\#module-re}{re} 模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{re}\PYG{o}{.}\PYG{n}{findall}\PYG{p}{(}\PYG{l+s}{r\PYGZsq{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{bf[a\PYGZhy{}z]*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{which foot or hand fell fastest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}foot\PYGZsq{}, \PYGZsq{}fell\PYGZsq{}, \PYGZsq{}fastest\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{re}\PYG{o}{.}\PYG{n}{sub}\PYG{p}{(}\PYG{l+s}{r\PYGZsq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{b[a\PYGZhy{}z]+) }\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{r\PYGZsq{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cat in the the hat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}cat in the hat\PYGZsq{}}
\end{Verbatim}

只需简单的操作时，字符串方法最好用，因为它们易读，又容易调试:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tea for too}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{too}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}tea for two\PYGZsq{}}
\end{Verbatim}


\section{数学}
\label{stdlib:tut-mathematics}\label{stdlib:id6}
\href{https://docs.python.org/3/library/math.html\#module-math}{math} 模块为浮点运算提供了对底层C函数库的访问:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mf}{4.0}\PYG{p}{)}
\PYG{g+go}{0.70710678118654757}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{10.0}
\end{Verbatim}

\href{https://docs.python.org/3/library/random.html\#module-random}{random} 提供了生成随机数的工具:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{random}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{banana}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}apple\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{random}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}   \PYG{c}{\PYGZsh{} sampling without replacement}
\PYG{g+go}{[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)}    \PYG{c}{\PYGZsh{} random float}
\PYG{g+go}{0.17970987693706186}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{random}\PYG{o}{.}\PYG{n}{randrange}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}    \PYG{c}{\PYGZsh{} random integer chosen from range(6)}
\PYG{g+go}{4}
\end{Verbatim}

\href{https://docs.python.org/3/library/statistics.html\#module-statistics}{statistics} 模块用于计算基础的统计特征相关的数据值（平均数, 中值, 方差等）:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{statistics}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.75}\PYG{p}{,} \PYG{l+m+mf}{1.75}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.25}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{statistics}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{g+go}{1.6071428571428572}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{statistics}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{g+go}{1.25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{statistics}\PYG{o}{.}\PYG{n}{variance}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{g+go}{1.3720238095238095}
\end{Verbatim}

SciPy \textless{}\href{http://scipy.org}{http://scipy.org}\textgreater{} 项目提供了许多数值计算的模块。


\section{互联网访问}
\label{stdlib:id7}\label{stdlib:tut-internet-access}
有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的
数据的 \href{https://docs.python.org/3/library/urllib.request.html\#module-urllib.request}{urllib.request} 以及用于发送电子邮件的 \href{https://docs.python.org/3/library/smtplib.html\#module-smtplib}{smtplib}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{urllib.request} \PYG{k+kn}{import} \PYG{n}{urlopen}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{urlopen}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://tycho.usno.navy.mil/cgi\PYGZhy{}bin/timer.pl}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{line} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{decode}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{utf\PYGZhy{}8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Decoding the binary data to text.}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{EST}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{line} \PYG{o+ow}{or} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{EDT}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}  \PYG{c}{\PYGZsh{} look for Eastern Time}
\PYG{g+gp}{... }        \PYG{k}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}

\PYG{g+go}{\PYGZlt{}BR\PYGZgt{}Nov. 25, 09:43:32 PM EST}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{smtplib}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{server} \PYG{o}{=} \PYG{n}{smtplib}\PYG{o}{.}\PYG{n}{SMTP}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{localhost}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{server}\PYG{o}{.}\PYG{n}{sendmail}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{soothsayer@example.org}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jcaesar@example.org}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}To: jcaesar@example.org}
\PYG{g+gp}{... }\PYG{l+s+sd}{From: soothsayer@example.org}
\PYG{g+gp}{...}
\PYG{g+gp}{... }\PYG{l+s+sd}{Beware the Ides of March.}
\PYG{g+gp}{... }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{server}\PYG{o}{.}\PYG{n}{quit}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

(注意第二个例子需要在 localhost 运行一个邮件服务器。)


\section{日期和时间}
\label{stdlib:id8}\label{stdlib:tut-dates-and-times}
\href{https://docs.python.org/3/library/datetime.html\#module-datetime}{datetime} 模块为日期和时间处理，即提供了简单的方法也包括了复杂的方法。
支持日期和时间算法的同时，实现的重点放在了更有效的处理和格式化输出。
该模块还支持时区处理。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} dates are easily constructed and formatted}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{date}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{now} \PYG{o}{=} \PYG{n}{date}\PYG{o}{.}\PYG{n}{today}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{now}
\PYG{g+go}{datetime.date(2003, 12, 2)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{now}\PYG{o}{.}\PYG{n}{strftime}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{m\PYGZhy{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{y. }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{b }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{Y is a }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{A on the }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ day of }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{B.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}12\PYGZhy{}02\PYGZhy{}03. 02 Dec 2003 is a Tuesday on the 02 day of December.\PYGZsq{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} dates support calendar arithmetic}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{birthday} \PYG{o}{=} \PYG{n}{date}\PYG{p}{(}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{31}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{age} \PYG{o}{=} \PYG{n}{now} \PYG{o}{\PYGZhy{}} \PYG{n}{birthday}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{age}\PYG{o}{.}\PYG{n}{days}
\PYG{g+go}{14368}
\end{Verbatim}


\section{数据压缩}
\label{stdlib:id9}\label{stdlib:tut-data-compression}
以下模块直接支持通用的数据打包和压缩格式：\href{https://docs.python.org/3/library/zlib.html\#module-zlib}{zlib}， \href{https://docs.python.org/3/library/gzip.html\#module-gzip}{gzip}， \href{https://docs.python.org/3/library/bz2.html\#module-bz2}{bz2}， \href{https://docs.python.org/3/library/lzma.html\#module-lzma}{lzma}， \href{https://docs.python.org/3/library/zipfile.html\#module-zipfile}{zipfile} 以及
\href{https://docs.python.org/3/library/tarfile.html\#module-tarfile}{tarfile}。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{zlib}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{b}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{witch which has which witches wrist watch}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{41}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{zlib}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{g+go}{37}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{zlib}\PYG{o}{.}\PYG{n}{decompress}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\PYG{g+go}{b\PYGZsq{}witch which has which witches wrist watch\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{zlib}\PYG{o}{.}\PYG{n}{crc32}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{g+go}{226805979}
\end{Verbatim}


\section{性能度量}
\label{stdlib:tut-performance-measurement}\label{stdlib:id10}
有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。

例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多。\href{https://docs.python.org/3/library/timeit.html\#module-timeit}{timeit} 证明了后者更快一些:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{timeit} \PYG{k+kn}{import} \PYG{n}{Timer}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Timer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t=a; a=b; b=t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a=1; b=2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{timeit}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0.57535828626024577}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Timer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a,b = b,a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a=1; b=2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{timeit}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0.54962537085770791}
\end{Verbatim}

相对于 \href{https://docs.python.org/3/library/timeit.html\#module-timeit}{timeit} 的细粒度，\href{https://docs.python.org/3/library/profile.html\#module-profile}{profile} 和 \href{https://docs.python.org/3/library/profile.html\#module-pstats}{pstats} 模块提供了针对更大代码块的时间度量工具。


\section{质量控制}
\label{stdlib:tut-quality-control}\label{stdlib:id11}
开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试。

\href{https://docs.python.org/3/library/doctest.html\#module-doctest}{doctest} 模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。
测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。
通过给用户提供例子，来改善文档，并允许 doctest 模块确认代码的结果是否与文档一致:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{average}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Computes the arithmetic mean of a list of numbers.}

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} print(average([20, 30, 70]))}
\PYG{l+s+sd}{    40.0}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{doctest}
\PYG{n}{doctest}\PYG{o}{.}\PYG{n}{testmod}\PYG{p}{(}\PYG{p}{)}   \PYG{c}{\PYGZsh{} automatically validate the embedded tests}
\end{Verbatim}

\href{https://docs.python.org/3/library/unittest.html\#module-unittest}{unittest} 模块不像 \href{https://docs.python.org/3/library/doctest.html\#module-doctest}{doctest} 模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{unittest}

\PYG{k}{class} \PYG{n+nc}{TestStatisticalFunctions}\PYG{p}{(}\PYG{n}{unittest}\PYG{o}{.}\PYG{n}{TestCase}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{test\PYGZus{}average}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assertEqual}\PYG{p}{(}\PYG{n}{average}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{40.0}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assertEqual}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{average}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{4.3}\PYG{p}{)}
        \PYG{k}{with} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assertRaises}\PYG{p}{(}\PYG{n+ne}{ZeroDivisionError}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{average}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{with} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assertRaises}\PYG{p}{(}\PYG{n+ne}{TypeError}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{average}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{)}

\PYG{n}{unittest}\PYG{o}{.}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Calling from the command line invokes all tests}
\end{Verbatim}


\section{自带能量包}
\label{stdlib:tut-batteries-included}\label{stdlib:id12}
Python 展现了“自带能量包”的哲学。这可以通过它更大的包的高级和健壮的功能来得到最好的展现。列如:
\begin{itemize}
\item {} 
\href{https://docs.python.org/3/library/xmlrpc.client.html\#module-xmlrpc.client}{xmlrpc.client} 和 \href{https://docs.python.org/3/library/xmlrpc.server.html\#module-xmlrpc.server}{xmlrpc.server} 模块让远程过程调用变得轻而易举。
除了模块的名字，用户无需拥有 XML 的知识或自己来处理 XML。

\item {} 
\href{https://docs.python.org/3/library/email.html\#module-email}{email} 包是一个管理邮件信息的库，包括MIME和其它基于 RFC2822 的信息文档。
不同于实际发送和接收信息的 \href{https://docs.python.org/3/library/smtplib.html\#module-smtplib}{smtplib} 和 \href{https://docs.python.org/3/library/poplib.html\#module-poplib}{poplib} 模块，email 包包含一个构造或解析复杂消息结构（包括附件）
及实现互联网编码和头协议的完整工具集。

\item {} 
\href{https://docs.python.org/3/library/xml.dom.html\#module-xml.dom}{xml.dom} 和 \href{https://docs.python.org/3/library/xml.sax.html\#module-xml.sax}{xml.sax} 包为流行的信息交换格式提供了强大的支持。同样， \href{https://docs.python.org/3/library/csv.html\#module-csv}{csv}  模块支持在通用数据库格式中直接读写。
综合起来，这些模块和包大大简化了 Python 应用程序和其它工具之间的数据交换。

\item {} 
国际化由 \href{https://docs.python.org/3/library/gettext.html\#module-gettext}{gettext} ， \href{https://docs.python.org/3/library/locale.html\#module-locale}{locale} 和 \href{https://docs.python.org/3/library/codecs.html\#module-codecs}{codecs} 包支持。

\end{itemize}


\chapter{标准库浏览 -- Part II}
\label{stdlib2:tut-brieftourtwo}\label{stdlib2:statistics}\label{stdlib2:part-ii}\label{stdlib2::doc}
第二部分包含了支持专业编程工作所需的更高级的模块，这些模块很少出现在小脚本中。


\section{输出格式}
\label{stdlib2:id1}\label{stdlib2:tut-output-formatting}
\href{https://docs.python.org/3/library/reprlib.html\#module-reprlib}{reprlib} 模块为大型的或深
度嵌套的容器缩写显示提供了 :\href{https://docs.python.org/3/library/functions.html\#repr}{repr()} 函数的一个定制版本:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{reprlib}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{reprlib}\PYG{o}{.}\PYG{n}{repr}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{supercalifragilisticexpialidocious}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZdq{}set([\PYGZsq{}a\PYGZsq{}, \PYGZsq{}c\PYGZsq{}, \PYGZsq{}d\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}f\PYGZsq{}, \PYGZsq{}g\PYGZsq{}, ...])\PYGZdq{}}
\end{Verbatim}

\href{https://docs.python.org/3/library/pprint.html\#module-pprint}{pprint} 模块给老手提供了一种
解释器可读的方式深入控制内置和用户自定义对象的打印。当输出超过一行的时候，
“美化打印（pretty printer）”添加断行和标识符，使得数据结构显示的更清晰:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pprint}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cyan}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{white}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{green}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{magenta}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yellow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pprint}\PYG{o}{.}\PYG{n}{pprint}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
\PYG{g+go}{[[[[\PYGZsq{}black\PYGZsq{}, \PYGZsq{}cyan\PYGZsq{}],}
\PYG{g+go}{   \PYGZsq{}white\PYGZsq{},}
\PYG{g+go}{   [\PYGZsq{}green\PYGZsq{}, \PYGZsq{}red\PYGZsq{}]],}
\PYG{g+go}{  [[\PYGZsq{}magenta\PYGZsq{}, \PYGZsq{}yellow\PYGZsq{}],}
\PYG{g+go}{   \PYGZsq{}blue\PYGZsq{}]]]}
\end{Verbatim}

\href{https://docs.python.org/3/library/textwrap.html\#module-textwrap}{textwrap} 模块格式化文本段落以适应设定的屏宽:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{textwrap}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{doc} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{The wrap() method is just like fill() except that it returns}
\PYG{g+gp}{... }\PYG{l+s}{a list of strings instead of one big string with newlines to separate}
\PYG{g+gp}{... }\PYG{l+s}{the wrapped lines.}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{n}{textwrap}\PYG{o}{.}\PYG{n}{fill}\PYG{p}{(}\PYG{n}{doc}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{The wrap() method is just like fill()}
\PYG{g+go}{except that it returns a list of strings}
\PYG{g+go}{instead of one big string with newlines}
\PYG{g+go}{to separate the wrapped lines.}
\end{Verbatim}

\href{https://docs.python.org/3/library/locale.html\#module-locale}{locale} 模块访问一个国家特定数据格式的数据库
locale 的格式化函数的属性集，提供了一种以组分隔，来直接格式化数字的方式。:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{locale}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{locale}\PYG{o}{.}\PYG{n}{setlocale}\PYG{p}{(}\PYG{n}{locale}\PYG{o}{.}\PYG{n}{LC\PYGZus{}ALL}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{English\PYGZus{}United States.1252}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}English\PYGZus{}United States.1252\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{conv} \PYG{o}{=} \PYG{n}{locale}\PYG{o}{.}\PYG{n}{localeconv}\PYG{p}{(}\PYG{p}{)}          \PYG{c}{\PYGZsh{} get a mapping of conventions}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{1234567.8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{locale}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{grouping}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}1,234,567\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{locale}\PYG{o}{.}\PYG{n}{format\PYGZus{}string}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+si}{\PYGZpc{}.*f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{currency\PYGZus{}symbol}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }                     \PYG{n}{conv}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{frac\PYGZus{}digits}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grouping}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZdl{}1,234,567.80\PYGZsq{}}
\end{Verbatim}


\section{模板}
\label{stdlib2:tut-templating}\label{stdlib2:id2}
\href{https://docs.python.org/3/library/string.html\#module-string}{string} 提供了一个
灵活多变的模版类 \href{https://docs.python.org/3/library/string.html\#string.Template}{Template} ，
它有一种适合用户编辑的简单语法。使用户可以在不改变的应用程序的情况下定制他们的应用程序。

格式使用 \code{\$} 为开头的 Python 合法标识（数字、字母和下划线）作为占位符。
占位符外面的大括号使它可以和其它的字符不加空格混在一起。 \code{\$\$} 创建一个单独的 \code{\$}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{string} \PYG{k+kn}{import} \PYG{n}{Template}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{Template}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdl{}\PYGZob{}village\PYGZcb{}folk send \PYGZdl{}\PYGZdl{}10 to \PYGZdl{}cause.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{n}{village}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Nottingham}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cause}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the ditch fund}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Nottinghamfolk send \PYGZdl{}10 to the ditch fund.\PYGZsq{}}
\end{Verbatim}

当一个占位符在字典或关键字参数中没有被提供时，
\href{https://docs.python.org/3/library/string.html\#string.Template.substitute}{substitute()}
方法就会抛出一个 \href{https://docs.python.org/3/library/exceptions.html\#KeyError}{KeyError} 异常。
对于 mail-merge 风格的应用程序，用户提供的数据可能并不完整，
这时使用 \href{https://docs.python.org/3/library/string.html\#string.Template.safe\_substitute}{safe\_substitute()}
方法可能更适合 — 如果数据不完整，它就不会改变占位符:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{Template}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Return the \PYGZdl{}item to \PYGZdl{}owner.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{item}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{unladen swallow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  \PYG{c}{...}
\PYG{g+gr}{KeyError}: \PYG{n}{\PYGZsq{}owner\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t}\PYG{o}{.}\PYG{n}{safe\PYGZus{}substitute}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}Return the unladen swallow to \PYGZdl{}owner.\PYGZsq{}}
\end{Verbatim}

模板子类可以指定一个自定义分隔符。例如，图像查看器的批量重命名工具可能选择使用百分号作为占位符，
像当前日期，图片序列号或文件格式:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{time}\PYG{o}{,} \PYG{n+nn}{os.path}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{photofiles} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{img\PYGZus{}1074.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{img\PYGZus{}1076.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{img\PYGZus{}1077.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{BatchRename}\PYG{p}{(}\PYG{n}{Template}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{delimiter} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fmt} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Enter rename style (}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZhy{}date }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{n\PYGZhy{}seqnum }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{\PYGZhy{}format):  }\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{Enter rename style (\PYGZpc{}d\PYGZhy{}date \PYGZpc{}n\PYGZhy{}seqnum \PYGZpc{}f\PYGZhy{}format):  Ashley\PYGZus{}\PYGZpc{}n\PYGZpc{}f}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t} \PYG{o}{=} \PYG{n}{BatchRename}\PYG{p}{(}\PYG{n}{fmt}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{date} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{strftime}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{filename} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{photofiles}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{base}\PYG{p}{,} \PYG{n}{ext} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{splitext}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{newname} \PYG{o}{=} \PYG{n}{t}\PYG{o}{.}\PYG{n}{substitute}\PYG{p}{(}\PYG{n}{d}\PYG{o}{=}\PYG{n}{date}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{n}{f}\PYG{o}{=}\PYG{n}{ext}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0\PYGZcb{} \PYGZhy{}\PYGZhy{}\PYGZgt{} \PYGZob{}1\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{newname}\PYG{p}{)}\PYG{p}{)}

\PYG{g+go}{img\PYGZus{}1074.jpg \PYGZhy{}\PYGZhy{}\PYGZgt{} Ashley\PYGZus{}0.jpg}
\PYG{g+go}{img\PYGZus{}1076.jpg \PYGZhy{}\PYGZhy{}\PYGZgt{} Ashley\PYGZus{}1.jpg}
\PYG{g+go}{img\PYGZus{}1077.jpg \PYGZhy{}\PYGZhy{}\PYGZgt{} Ashley\PYGZus{}2.jpg}
\end{Verbatim}

模板的另一个应用是把多样的输出格式细节从程序逻辑中分类出来。
这便使得 XML 文件，纯文本报表和 HTML WEB 报表定制模板成为可能。


\section{使用二进制数据记录布局}
\label{stdlib2:id3}\label{stdlib2:tut-binary-formats}
\href{https://docs.python.org/3/library/struct.html\#module-struct}{struct} 模块为使用变长的二进制记录格式
提供了 \href{https://docs.python.org/3/library/struct.html\#struct.pack}{pack()} 和
\href{https://docs.python.org/3/library/struct.html\#struct.unpack}{unpack()} 函数。
下面的示例演示了在不使用 \href{https://docs.python.org/3/library/zipfile.html\#module-zipfile}{zipfile}
模块的情况下如何迭代一个 ZIP 文件的头信息。压缩码 \code{"H"} 和 \code{"I"} 分别表示2和4字节无符号数字，
\code{"\textless{}"} 表明它们都是标准大小并且按照 little-endian 字节排序。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{struct}

\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{myfile.zip}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}                      \PYG{c}{\PYGZsh{} show the first 3 file headers}
    \PYG{n}{start} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{14}
    \PYG{n}{fields} \PYG{o}{=} \PYG{n}{struct}\PYG{o}{.}\PYG{n}{unpack}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}IIIHH}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{16}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{crc32}\PYG{p}{,} \PYG{n}{comp\PYGZus{}size}\PYG{p}{,} \PYG{n}{uncomp\PYGZus{}size}\PYG{p}{,} \PYG{n}{filenamesize}\PYG{p}{,} \PYG{n}{extra\PYGZus{}size} \PYG{o}{=} \PYG{n}{fields}

    \PYG{n}{start} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{16}
    \PYG{n}{filename} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{start}\PYG{o}{+}\PYG{n}{filenamesize}\PYG{p}{]}
    \PYG{n}{start} \PYG{o}{+}\PYG{o}{=} \PYG{n}{filenamesize}
    \PYG{n}{extra} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{start}\PYG{o}{+}\PYG{n}{extra\PYGZus{}size}\PYG{p}{]}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n+nb}{hex}\PYG{p}{(}\PYG{n}{crc32}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comp\PYGZus{}size}\PYG{p}{,} \PYG{n}{uncomp\PYGZus{}size}\PYG{p}{)}

    \PYG{n}{start} \PYG{o}{+}\PYG{o}{=} \PYG{n}{extra\PYGZus{}size} \PYG{o}{+} \PYG{n}{comp\PYGZus{}size}     \PYG{c}{\PYGZsh{} skip to the next header}
\end{Verbatim}


\section{多线程}
\label{stdlib2:id4}\label{stdlib2:tut-multi-threading}
线程是一项分离任务的技术，这些任务无顺序依赖关系。在某些任务运行于后台的时候应用程序会变得迟缓，
线程可以提升其速度。一个有关的用途是在 I/O 的同时其它线程可以并行计算。

下面的代码显示了高级模块 \href{https://docs.python.org/3/library/threading.html\#module-threading}{threading}
如何在主程序运行的同时运行任务:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{threading}\PYG{o}{,} \PYG{n+nn}{zipfile}

\PYG{k}{class} \PYG{n+nc}{AsyncZip}\PYG{p}{(}\PYG{n}{threading}\PYG{o}{.}\PYG{n}{Thread}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{infile}\PYG{p}{,} \PYG{n}{outfile}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{threading}\PYG{o}{.}\PYG{n}{Thread}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{infile} \PYG{o}{=} \PYG{n}{infile}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{outfile} \PYG{o}{=} \PYG{n}{outfile}
    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{f} \PYG{o}{=} \PYG{n}{zipfile}\PYG{o}{.}\PYG{n}{ZipFile}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{outfile}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{zipfile}\PYG{o}{.}\PYG{n}{ZIP\PYGZus{}DEFLATED}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{infile}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Finished background zip of:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{infile}\PYG{p}{)}

\PYG{n}{background} \PYG{o}{=} \PYG{n}{AsyncZip}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mydata.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{myarchive.zip}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{background}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The main program continues to run in foreground.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{background}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{)}    \PYG{c}{\PYGZsh{} Wait for the background task to finish}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Main program waited until background was done.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

多线程应用程序的主要挑战是协调线程，诸如线程间共享数据或其它的资源。为了达到那个目的，
线程模块提供了许多同步化的原生支持，包括：锁，事件，条件变量和信号灯。

尽管这些工具很强大，微小的设计错误也可能造成难以挽回的故障。因此，任务协调的首选方法是把
对一个资源的所有访问集中在一个单独的线程中，这个单独的线程使用 \href{https://docs.python.org/3/library/queue.html\#module-queue}{queue}
模块来服务其他线程的请求。应用程序使用 \href{https://docs.python.org/3/library/queue.html\#queue.Queue}{Queue 对象} ，使得
内部线程通信和协调更容易设计，应用程序更易读和可靠。


\section{日志}
\label{stdlib2:tut-logging}\label{stdlib2:id6}
\href{https://docs.python.org/3/library/logging.html\#module-logging}{logging} 模块提供了完整和灵活的日志系统。
它最简单的用法是记录信息并发送到一个文件或 \code{sys.stderr}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{debug}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Debugging information}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Informational message}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{warning}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Warning:config file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ not found}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{server.conf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Error occurred}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{logging}\PYG{o}{.}\PYG{n}{critical}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Critical error \PYGZhy{}\PYGZhy{} shutting down}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

输出如下:

\begin{Verbatim}[commandchars=\\\{\}]
WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error \PYGZhy{}\PYGZhy{} shutting down
\end{Verbatim}

默认情况下捕获信息和调试消息并将输出发送到标准错误流。其它可选的路由信息方式通过 email，
数据报文，socket 或者 HTTP Server。基于消息属性，新的过滤器可以选择不同的路由： \code{DEBUG}， \code{INFO}，
\code{WARNING}， \code{ERROR} 和 \code{CRITICAL} 。

日志系统可以直接在 Python 代码中定制，也可以不经过应用程序直接在一个用户可编辑的配置文件中加载。


\section{弱引用}
\label{stdlib2:id7}\label{stdlib2:tut-weak-references}
Python 自动进行内存管理（对大多数的对象进行引用计数和
\href{https://docs.python.org/3/glossary.html\#term-garbage-collection}{垃圾回收} 以循环利用）。
在最后一个引用消失后，内存会很快释放。

这个工作方式对大多数应用程序工作良好，但是偶尔会需要跟踪对象来做一些事。
不幸的是，仅仅为跟踪它们创建引用也会使其长期存在。 \href{https://docs.python.org/3/library/weakref.html\#module-weakref}{weakref}
模块提供了不用创建引用的跟踪对象工具，一旦对象不再存在，它自动从弱引用表上删除并触发回调。典型的应用包括捕获难以构造的对象:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{weakref}\PYG{o}{,} \PYG{n+nn}{gc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{A}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value} \PYG{o}{=} \PYG{n}{value}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{return} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{A}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}                   \PYG{c}{\PYGZsh{} create a reference}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{n}{weakref}\PYG{o}{.}\PYG{n}{WeakValueDictionary}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{primary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}            \PYG{c}{\PYGZsh{} does not create a reference}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{primary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}                \PYG{c}{\PYGZsh{} fetch the object if it is still alive}
\PYG{g+go}{10}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{del} \PYG{n}{a}                       \PYG{c}{\PYGZsh{} remove the one reference}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{gc}\PYG{o}{.}\PYG{n}{collect}\PYG{p}{(}\PYG{p}{)}                \PYG{c}{\PYGZsh{} run garbage collection right away}
\PYG{g+go}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{primary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}                \PYG{c}{\PYGZsh{} entry was automatically removed}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
    \PYG{n}{d}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{primary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}                \PYG{c}{\PYGZsh{} entry was automatically removed}
  File \PYG{n+nb}{\PYGZdq{}C:/python34/lib/weakref.py\PYGZdq{}}, line \PYG{l+m}{46}, in \PYG{n}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}
    \PYG{n}{o} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gr}{KeyError}: \PYG{n}{\PYGZsq{}primary\PYGZsq{}}
\end{Verbatim}


\section{列表工具}
\label{stdlib2:id9}\label{stdlib2:tut-list-tools}
很多数据结构可能会用到内置列表类型。然而，有时可能需要不同性能代价的实现。

\href{https://docs.python.org/3/library/array.html\#module-array}{array} 模块提供了一个类似
列表的 \href{https://docs.python.org/3/library/array.html\#array.array}{array()} 对象，它仅仅是存储数据，
更为紧凑。以下的示例演示了一个存储双字节无符号整数的数组（类型编码 \code{"H"} ）而非存储 16 字节 Python 整数对象的普通正规列表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{array} \PYG{k+kn}{import} \PYG{n}{array}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{H}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4000}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{700}\PYG{p}{,} \PYG{l+m+mi}{22222}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{26932}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+go}{array(\PYGZsq{}H\PYGZsq{}, [10, 700])}
\end{Verbatim}

\href{https://docs.python.org/3/library/collections.html\#module-collections}{collections} 模块提供了类
似列表的 \href{https://docs.python.org/3/library/collections.html\#collections.deque}{deque()} 对象，
它从左边添加（append）和弹出（pop）更快，但是在内部查询更慢。
这些对象更适用于队列实现和广度优先的树搜索:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{deque}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{task1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{task2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{task3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{task4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Handling}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{d}\PYG{o}{.}\PYG{n}{popleft}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Handling task1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{unsearched} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{[}\PYG{n}{starting\PYGZus{}node}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{breadth\PYGZus{}first\PYGZus{}search}\PYG{p}{(}\PYG{n}{unsearched}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{node} \PYG{o}{=} \PYG{n}{unsearched}\PYG{o}{.}\PYG{n}{popleft}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n}{gen\PYGZus{}moves}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{is\PYGZus{}goal}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{m}
        \PYG{n}{unsearched}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\end{Verbatim}

除了链表的替代实现，该库还提供了 \href{https://docs.python.org/3/library/bisect.html\#module-bisect}{bisect} 这样的模块
以操作已排序的链表:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{bisect}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{perl}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tcl}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lua}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bisect}\PYG{o}{.}\PYG{n}{insort}\PYG{p}{(}\PYG{n}{scores}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ruby}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{scores}
\PYG{g+go}{[(100, \PYGZsq{}perl\PYGZsq{}), (200, \PYGZsq{}tcl\PYGZsq{}), (300, \PYGZsq{}ruby\PYGZsq{}), (400, \PYGZsq{}lua\PYGZsq{}), (500, \PYGZsq{}python\PYGZsq{})]}
\end{Verbatim}

\href{https://docs.python.org/3/library/heapq.html\#module-heapq}{heapq} 提供了基于正规链表的堆实现。
最小的值总是保持在 0 点。这在希望循环访问最小元素但是不想执行完整堆排序的时候非常有用:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{heapq} \PYG{k+kn}{import} \PYG{n}{heapify}\PYG{p}{,} \PYG{n}{heappop}\PYG{p}{,} \PYG{n}{heappush}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heapify}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}                      \PYG{c}{\PYGZsh{} rearrange the list into heap order}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{heappush}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}                 \PYG{c}{\PYGZsh{} add a new entry}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{heappop}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}  \PYG{c}{\PYGZsh{} fetch the three smallest entries}
\PYG{g+go}{[\PYGZhy{}5, 0, 1]}
\end{Verbatim}


\section{十进制浮点数算法}
\label{stdlib2:id11}\label{stdlib2:tut-decimal-fp}
\href{https://docs.python.org/3/library/decimal.html\#module-decimal}{decimal 模块} 提供了
一个 \href{https://docs.python.org/3/library/decimal.html\#decimal.Decimal}{Decimal} 数据类型用于浮点数计算。
相比内置的二进制浮点数 \href{https://docs.python.org/3/library/functions.html\#float}{float}，这个类型有助于
\begin{itemize}
\item {} 
金融应用和其它需要精确十进制表达的场合，

\item {} 
控制精度，

\item {} 
控制舍入以适应法律或者规定要求，

\item {} 
确保十进制数位精度，或者

\item {} 
用户希望计算结果与手算相符的场合。

\end{itemize}

例如，计算 70 分电话费的 5\% 税计算，十进制浮点数和二进制浮点数计算结果的差别如下。如果在分值上舍入，这个差别就很重要了:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{decimal} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{Decimal}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0.70}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{*} \PYG{n}{Decimal}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1.05}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{Decimal(\PYGZsq{}0.74\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{70} \PYG{o}{*} \PYG{l+m+mf}{1.05}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{0.73}
\end{Verbatim}

\href{https://docs.python.org/3/library/decimal.html\#decimal.Decimal}{Decimal} 的结果总是保留结尾的 0，
自动从两位精度延伸到4位。Decimal 重现了手工的数学运算，这就确保了二进制浮点数无法精确保留的数据精度。

高精度使 \href{https://docs.python.org/3/library/decimal.html\#decimal.Decimal}{Decimal} 可以执行
二进制浮点数无法进行的模运算和等值测试:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Decimal}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1.00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{Decimal}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.10}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{Decimal(\PYGZsq{}0.00\PYGZsq{})}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{1.00} \PYG{o}{\PYGZpc{}} \PYG{l+m+mf}{0.10}
\PYG{g+go}{0.09999999999999995}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Decimal}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0.1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{==} \PYG{n}{Decimal}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{1.0}
\PYG{g+go}{False}
\end{Verbatim}

\href{https://docs.python.org/3/library/decimal.html\#module-decimal}{decimal 模块} 提供了必须的高精度算法:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{getcontext}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{prec} \PYG{o}{=} \PYG{l+m+mi}{36}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Decimal}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Decimal}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{g+go}{Decimal(\PYGZsq{}0.142857142857142857142857142857142857\PYGZsq{})}
\end{Verbatim}


\chapter{虚拟环境和包}
\label{venv:tut-venv}\label{venv:id1}\label{venv::doc}

\section{介绍}
\label{venv:id2}
在 Python 应用程序中经常会用到非标准库的模块和包（译者注：即其他人开发的程序）
。应用程序有时需要某个类库的特殊版本，因为应用程序可能需要某个指定的bug被修复了的类库
或者这个应用程序可能使用了老的版本的类库接口

这就意味着仅安装一个 Python 将不能满足每个应用程序的需求， 如果应用程序A需要某个指定模块的 1.0 版本，
但是应用程序B则需要这个模块的 2.0 版本， 那么这个需求存在冲突，
因为无论安装版本 1.0 还是 2.0 都将导致一个应用程序无法正常运行。

解决这个问题的办法是创建一个 \DUspan{xref,std,std-term}{虚拟环境} （英文简称 ``virtualenv''），
它是一个自包含的目录，里面有安装指定版本的 Python ，外加一些额外的包 （译者注：在虚拟环境下安装的其他非标准库）

不同的应用程序可以使用不同的虚拟环境。要解决先前例子中的冲突需求，应用程序 A 可以有它自己的安装了版本 1.0 的虚拟环境
而应用程序 B 可以有另外一个版本 2.0 的虚拟环境。如果应用程序B需要一个类库升级到版本 3.0 ，那么这个升级过程将不会影响应用程序
A的环境。


\section{创建虚拟环境}
\label{venv:id3}
被用来创建和管理虚拟环境的脚本叫做 \textbf{\texttt{pyvenv}} 。 \textbf{\texttt{pyvenv}} 脚本通常会安装在你可以使用的最近版本的 Python 中；
这个脚本安装完也带有版本号，因此如果在你的系统中有多个版本的 Python ， 你可以通过执行 \code{pyvenv-3.4} 或者
你希望的其他版本的 \textbf{\texttt{pyvenv}} 来选择一个特殊版本的 Python 。

要想创建一个虚拟环境，需要在你想放置虚拟环境的地方即某个目录下，执行 \textbf{\texttt{pyvenv}} ，后面跟上目录路径:

\begin{Verbatim}[commandchars=\\\{\}]
pyvenv tutorial\PYGZhy{}env
\end{Verbatim}

如果 \code{tutorial-env} 目录不存在， 这样就会创建这个目录，
并且在这个目录下面生成一份拷贝的 Python 解释器，标准库和各种支持文件。

一旦你创建了一个虚拟环境，你需要激活它。

在 Windows 上， 运行:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tutorial}\PYG{o}{\PYGZhy{}}\PYG{n}{env}\PYG{o}{/}\PYG{n}{Scripts}\PYG{o}{/}\PYG{n}{activate}
\end{Verbatim}

在 Unix  和 MacOS 上， 运行:

\begin{Verbatim}[commandchars=\\\{\}]
source tutorial\PYGZhy{}env/bin/activate
\end{Verbatim}

（这个脚本是基于 bash shell 写的。 如果你使用的是 \textbf{\texttt{csh}} 或者 \textbf{\texttt{fish}} shell ，
你需要使用 \code{activate.csh} 或 \code{activate.fish} 来代替前面命令中的 \code{activate} ）

激活了虚拟环境后， 你将会看到 shell 的提示符显示当前你所应用的虚拟环境，并且在你运行 \code{python} 时，
当前环境将会变成你安装的指定版本 Python 。例如:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZgt{} source \PYGZti{}/envs/tutorial\PYGZhy{}env/bin/activate
(tutorial\PYGZhy{}env) \PYGZhy{}\PYGZgt{} python
Python 3.4.3+ (3.4:c7b9645a6f35+, May 22 2015, 09:31:25)
  ...
\PYGZgt{}\PYGZgt{}\PYGZgt{} import sys
\PYGZgt{}\PYGZgt{}\PYGZgt{} sys.path
[\PYGZsq{}\PYGZsq{}, \PYGZsq{}/usr/local/lib/python34.zip\PYGZsq{}, ...,
\PYGZsq{}\PYGZti{}/envs/tutorial\PYGZhy{}env/lib/python3.4/site\PYGZhy{}packages\PYGZsq{}]
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{Verbatim}


\section{使用 pip 管理包}
\label{venv:pip}
一旦你已经激活了一个虚拟环境， 你可以通过 \textbf{\texttt{pip}} 程序安装，升级和移除包。默认 \code{pip} 会
从 Python 官方类库 \textless{}\href{https://pypi.python.org/pypi}{https://pypi.python.org/pypi}\textgreater{} 中安装包， 你可以通过浏览器浏览 Python 官方类库，
或者你可以使用 \code{pip} 的定制搜索功能:

\begin{Verbatim}[commandchars=\\\{\}]
(tutorial\PYGZhy{}env) \PYGZhy{}\PYGZgt{} pip search astronomy
skyfield               \PYGZhy{} Elegant astronomy for Python
gary                   \PYGZhy{} Galactic astronomy and gravitational dynamics.
novas                  \PYGZhy{} The United States Naval Observatory NOVAS astronomy library
astroobs               \PYGZhy{} Provides astronomy ephemeris to plan telescope observations
PyAstronomy            \PYGZhy{} A collection of astronomy related tools for Python.
...
\end{Verbatim}

\code{pip} 有一些子命令: ``search''，''install''，''uninstall''，''freeze''，等。
（详情，请查看完整的 \code{pip} 手册 \href{https://docs.python.org/3/installing/index.html\#installing-index}{安装 Python 模块} 。）

你可以指定一个包的名字来安装最近版本包:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZgt{} pip install novas
Collecting novas
  Downloading novas\PYGZhy{}3.1.1.3.tar.gz (136kB)
Installing collected packages: novas
  Running setup.py install for novas
Successfully installed novas\PYGZhy{}3.1.1.3
\end{Verbatim}

你可以安装一个指定版本的包，只要在 \code{==} 后面加上包名的版本号:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZgt{} pip install requests==2.6.0
Collecting requests==2.6.0
  Using cached requests\PYGZhy{}2.6.0\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
Installing collected packages: requests
Successfully installed requests\PYGZhy{}2.6.0
\end{Verbatim}

如果继续运行上面的命令，将不执行任何操作， \code{pip} 会提示你 request 2.6.0 已经安装，
你可以通过提供一个不同的版本号来获取其他版本或者你也可以运行 \code{pip install -{-}upgrade} 来升级这个包到最新版本:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZgt{} pip install \PYGZhy{}\PYGZhy{}upgrade requests
Collecting requests
Installing collected packages: requests
  Found existing installation: requests 2.6.0
    Uninstalling requests\PYGZhy{}2.6.0:
      Successfully uninstalled requests\PYGZhy{}2.6.0
Successfully installed requests\PYGZhy{}2.7.0
\end{Verbatim}

在 \code{pip uninstall} 后面跟一个或者多个包的名字，将会从这个虚拟环境中移除这些包。

\code{pip show} 用来显示一个包的详细信息:

\begin{Verbatim}[commandchars=\\\{\}]
(tutorial\PYGZhy{}env) \PYGZhy{}\PYGZgt{} pip show requests
\PYGZhy{}\PYGZhy{}\PYGZhy{}
Metadata\PYGZhy{}Version: 2.0
Name: requests
Version: 2.7.0
Summary: Python HTTP for Humans.
Home\PYGZhy{}page: http://python\PYGZhy{}requests.org
Author: Kenneth Reitz
Author\PYGZhy{}email: me@kennethreitz.com
License: Apache 2.0
Location: /Users/akuchling/envs/tutorial\PYGZhy{}env/lib/python3.4/site\PYGZhy{}packages
Requires:
\end{Verbatim}

\code{pip list} 用来显示当前虚拟环境下安装的所有包:

\begin{Verbatim}[commandchars=\\\{\}]
(tutorial\PYGZhy{}env) \PYGZhy{}\PYGZgt{} pip list
novas (3.1.1.3)
numpy (1.9.2)
pip (7.0.3)
requests (2.7.0)
setuptools (16.0)
\end{Verbatim}

\code{pip freeze} 将会生成一个类似于安装包的列表，但是在输出的文本格式中不包含 \code{pip install} ，一个普遍的
做法是将这个列表放到一个 \code{requirements.txt} 文件中:

\begin{Verbatim}[commandchars=\\\{\}]
(tutorial\PYGZhy{}env) \PYGZhy{}\PYGZgt{} pip freeze \PYGZgt{} requirements.txt
(tutorial\PYGZhy{}env) \PYGZhy{}\PYGZgt{} cat requirements.txt
novas==3.1.1.3
numpy==1.9.2
requests==2.7.0
\end{Verbatim}

这个 \code{requirements.txt} 文件将会被提交到版本控制（译者注：通过git，svn等的工具可以进行代码版本的控制）中，
并作为应用程序的一部分。这样用户可以通过 \code{install -r} 安装所有需要的包:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZgt{} pip install \PYGZhy{}r requirements.txt
Collecting novas==3.1.1.3 (from \PYGZhy{}r requirements.txt (line 1))
  ...
Collecting numpy==1.9.2 (from \PYGZhy{}r requirements.txt (line 2))
  ...
Collecting requests==2.7.0 (from \PYGZhy{}r requirements.txt (line 3))
  ...
Installing collected packages: novas, numpy, requests
  Running setup.py install for novas
Successfully installed novas\PYGZhy{}3.1.1.3 numpy\PYGZhy{}1.9.2 requests\PYGZhy{}2.7.0
\end{Verbatim}

\code{pip} 有非常多的选项。详情请参考 \code{pip} 完整的指导手册 \href{https://docs.python.org/3/installing/index.html\#installing-index}{安装 Python 模块} 。 如果你自己写了
一个包，想把它放到 Python 官方类库中，请参考 \href{https://docs.python.org/3/distributing/index.html\#distributing-index}{发布 Python 模块} 。


\chapter{接下来？}
\label{whatnow:id4}\label{whatnow:tut-whatnow}\label{whatnow::doc}\label{whatnow:id1}
读过这本指南应该会让你有兴趣使用 Python --- 可能你已经期待着用 Python 解决你的实际问题了。
你可以在哪里进行一步学习了？

入门指南是 Python 文档集的一部分。其中的另一些文档包括：
\begin{itemize}
\item {} 
\href{https://docs.python.org/3/library/index.html\#library-index}{Python 标准库}：

应该浏览一下这份文档，它为标准库中的类型、函数和模块提供了完整（尽管很简略）的参考资料。
标准的 Python 发布版包括了大量的附加模块。其中有针对读取 Unix 邮箱、接收 HTTP 文档、生成随机数、
解析命令行选项、写 CGI 程序、压缩数据以及很多其它任务的模块。略读一下库参考会给你很多解决问题的思路。

\item {} 
\href{https://docs.python.org/3/installing/index.html\#installing-index}{安装 Python 模块} 展示了如何
安装其他 Python 用户编写的附加模块。

\item {} 
\href{https://docs.python.org/3/reference/index.html\#reference-index}{Python 语言参考}： 详细说明了 Python 语法和语义。
它读起来很累，不过对于语言本身，有份完整的手册很有用。

\end{itemize}

其它 Python 资源：
\begin{itemize}
\item {} 
\href{http://www.python.org}{http://www.python.org}： Python 官方网站。它包含代码、文档和 Web 上与 Python 有关的页面链接，
该网站镜像遍布于全世界各个角落，例如欧洲、日本和澳大利亚。
镜像可能会比主站快，这取决于你的地理位置。

\item {} 
\href{http://docs.python.org}{http://docs.python.org}： 快速访问 Python 的文档。

\item {} 
\href{http://pypi.python.org}{http://pypi.python.org}： Python 包索引，以前昵称为奶酪店，索引了可供下载的，用户创建的 Python 模块。
如果你发布了代码，可以注册到这里来，这样别人可以找到它。

\item {} 
\href{http://code.activestate.com/recipes/langs/python/}{http://code.activestate.com/recipes/langs/python/}： Python Cookbook 包含大量的示例代码、大型的模块，和有用的脚本。
值得关注的是这些资源已经集结成书，名为《Python Cookbook》（O’Reilly \& Associates, ISBN 0-596-00797-3。）

\item {} 
\href{http://scipy.org}{http://scipy.org}: The Scientific Python 项目包括数组快速计算和处理模块，和大量线性代数、
傅里叶变换、非线性solvers、随机数分布，统计分析以及类似的包。

\end{itemize}

与 Python 有关的问题，以及问题报告，可以发到新闻组 \emph{\texttt{comp.lang.python}} ，
或者发送到邮件组 \href{mailto:python-list@python.org}{python-list@python.org} 。新闻组和邮件组是开放的，所以发送的消息可以
自动的跟到另一个之后。每天有超过 120 个投递（高峰时有数百）,提问（以及回答）问题，为新功能提建议，
发布新模块。在发信之前，请查阅 \href{http://www.python.org/doc/faq/}{常见问题} (亦称 FAQ)，或者在 Python 源码发布包的 \code{Misc/} 目录中查阅。
邮件组也可以在 \href{http://mail.python.org/pipermail/}{http://mail.python.org/pipermail/} 访问。FAQ回答了很多被反复提到的问题，它很可能已经解答了你的问题。


\chapter{交互式输入行编辑和历史回溯}
\label{interactive:id1}\label{interactive::doc}\label{interactive:tut-interacting}
某些版本的 Python 解释器支持编辑当前的输入行和历史记录，类似于在 Korn shell 和 GNU Bash shell 中看到的功能。
这是使用 \href{http://tiswww.case.edu/php/chet/readline/rltop.html}{GNU Readline} 库实现的，它支持各种编辑风格。 这个库有它自己的文档，在这里我们不就重复了。


\section{Tab 补全和历史编辑}
\label{interactive:tut-keybindings}\label{interactive:tab}
变量和模块名的补全在解释器启动时 \href{https://docs.python.org/3/library/site.html\#rlcompleter-config}{自动打开}
以便 \code{Tab} 键调用补全功能；它会查看Python语句的名字，当前局部变量以及可以访问的模块名。
对于点表达式如 \code{string.a}，它将求出表达式最后一个 \code{'.'} 之前的值，然后根据结果的属性给出补全的建议。
注意，如果一个具有 \href{https://docs.python.org/3/reference/datamodel.html\#object.\_\_getattr\_\_}{\_\_getattr\_\_()}
方法的对象是表达式的某部分，这可能执行应用程序定义的代码。默认的配置同时会把历史记录保存在你的用户目录下一个
名为 \code{.python\_history} 的文件中。在下次与交互式解释器的会话中，历史记录将还可以访问。


\section{其它交互式解释器}
\label{interactive:tut-commentary}\label{interactive:id3}
与早期版本的解释器相比，现在是有了巨大的进步；然而，有些愿望还是没有实现：
如果能对连续的行给出正确的建议就更好了（解析器知道下一行是否需要缩进）。
补全机制可以使用解释器的符号表。检查（或者只是建议）匹配的括号、 引号的命令等也会非常有用。

一个增强的交互式解释器是 \href{http://ipython.scipy.org/}{IPython}，它已经存在相当一段时间，具有 tab 补全、 对象查看和高级的历史记录功能。
它也可以彻底定制并嵌入到其他应用程序中。另一个类似的增强的交互式环境是 \href{http://www.bpython-interpreter.org/}{bpython}。


\chapter{浮点数算法：争议和限制}
\label{floatingpoint:bpython}\label{floatingpoint:id1}\label{floatingpoint::doc}\label{floatingpoint:tut-fp-issues}
浮点数在计算机中表达为二进制（binary）小数。例如：十进制小数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.125}
\end{Verbatim}

是 1/10 + 2/100 + 5/1000 的值，同样二进制小数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.001}
\end{Verbatim}

是 0/2 + 0/4 + 1/8。这两个数值相同。唯一的实质区别是第一个写为十进制小数记法，第二个是二进制。

不幸的是，大多数十进制小数不能完全用二进制小数表示。结果是，一般情况下，你输入的十进制浮点数
仅由实际存储在计算机中的近似的二进制浮点数表示。

这个问题更早的时候首先在十进制中发现。考虑小数形式的 1/3 ，你可以来个十进制的近似值。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.3}
\end{Verbatim}

或者更进一步的,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.33}
\end{Verbatim}

或者更进一步的,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.333}
\end{Verbatim}

诸如此类。不管写多少位，这个结果永远不是精确的 1/3 ，但是可以无限接近 1/3 。

同样，无论在二进制中写多少位，十进制数 0.1 都不能精确表达为二进制小数。二进制来表达 1/10 是一个无限循环小数:

\begin{Verbatim}[commandchars=\\\{\}]
0.0001100110011001100110011001100110011001100110011...
\end{Verbatim}

在任何有限数量的位停下来，你得到的都是近似值。今天在大多数机器上，浮点数的近似使用的小数以最高的 53 位为分子，
2 的幂为分母。至于 1/10 这种情况，其二进制小数是  \code{3602879701896397 / 2 ** 55}，它非常接近但不完全等于1/10真实的值。

由于显示方式的原因，许多使用者意识不到是近似值。Python 只打印机器中存储的二进制值的十进制近似值。
在大多数机器上，如果 Python 要打印 0.1 存储的二进制的真正近似值，将会显示:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mf}{0.1}
\PYG{g+go}{0.1000000000000000055511151231257827021181583404541015625}
\end{Verbatim}

这么多位的数字对大多数人是没有用的，所以 Python 显示一个舍入的值

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{10}
\PYG{g+go}{0.1}
\end{Verbatim}

只要记住即使打印的结果看上去是精确的 1/10，真正存储的值是最近似的二进制小数。

有趣地是，存在许多不同的十进制数共享着相同的近似二进制小数。例如，数字 \code{0.1} 和 \code{0.10000000000000001}
以及 \code{0.1000000000000000055511151231257827021181583404541015625} 都是 \code{3602879701896397 / 2 ** 55} 的近似值。
因为所有这些十进制数共享相同的近似值，在保持恒等式 \code{eval(repr(x)) == x} 的同时，显示的可能是它们中的任何一个。

历史上，Python 提示符和内置的 \href{https://docs.python.org/3/library/functions.html\#repr}{repr()} 函数选择一个 17
位精度的数字，\code{0.10000000000000001}。从 Python 3.1 开始，Python（在大多数系统上）能够从这些数字当中选择最短的
一个并简单地显示 \code{0.1}。

注意，这是二进制浮点数的自然性质：它不是 Python 中的一个 bug，也不是你的代码中的 bug。
你会看到所有支持硬件浮点数算法的语言都会有这个现象（尽管有些语言默认情况下或者在所有输出模式下可能不会 \emph{显示} 出差异）。

为了输出更好看，你可能想用字符串格式化来生成固定位数的有效数字:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{format}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.12g}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}  \PYG{c}{\PYGZsh{} give 12 significant digits}
\PYG{g+go}{\PYGZsq{}3.14159265359\PYGZsq{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{format}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.2f}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}   \PYG{c}{\PYGZsh{} give 2 digits after the point}
\PYG{g+go}{\PYGZsq{}3.14\PYGZsq{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{repr}\PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}3.141592653589793\PYGZsq{}}
\end{Verbatim}

认识到这，在真正意义上，是一种错觉是很重要的：你在简单地舍入真实机器值的 \emph{显示}。

例如，既然 0.1 不是精确的 1/10，3 个 0.1 的值相加可能也不会得到精确的 0.3:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{==} \PYG{o}{.}\PYG{l+m+mi}{3}
\PYG{g+go}{False}
\end{Verbatim}

另外，既然 0.1 不能更接近 1/10 的精确值而且 0.3 不能更接近 3/10 的精确值，
使用 \href{https://docs.python.org/3/library/functions.html\#round}{round()} 函数提前舍入也没有帮助:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

虽然这些数字不可能再更接近它们想要的精确值，\href{https://docs.python.org/3/library/functions.html\#round}{round()}
函数可以用于在计算之后进行舍入，这样的话不精确的结果就可以和另外一个相比较了:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{round}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

二进制浮点数计算有很多这样意想不到的结果。“0.1”的问题在下面''误差的表示''一节中有准确详细的解释。
更完整的常见怪异现象请参见 \href{http://www.lahey.com/float.htm}{浮点数的危险}。

最后我要说，“没有简单的答案”。也不要过分小心浮点数！Python 浮点数计算中的误差源之于浮点数硬件，
大多数机器上每次计算误差不超过 2**53 分之一。对于大多数任务这已经足够了，但是你要在心中记住这不是十进制算法，
每个浮点数计算可能会带来一个新的舍入错误。

虽然确实有问题存在，对于大多数平常的浮点数运算，你只要简单地将最终显示的结果舍入到你期望的十进制位数，
你就会得到你期望的最终结果。\href{https://docs.python.org/3/library/stdtypes.html\#str}{str()} 通常已经足够用了，
对于更好的控制可以参阅 \href{https://docs.python.org/3/library/string.html\#formatstrings}{格式化字符串语法}
中 \href{https://docs.python.org/3/library/stdtypes.html\#str.format}{str.format()} 方法的格式说明符。

对于需要精确十进制表示的情况，可以尝试使用 \href{https://docs.python.org/3/library/decimal.html\#module-decimal}{decimal} 模块，
它实现的十进制运算适合会计方面的应用和高精度要求的应用。

\href{https://docs.python.org/3/library/fractions.html\#module-fractions}{fractions} 模块支持另外一种形式的运算，
它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。

如果你是浮点数操作的重度使用者，你应该看一下由 SciPy 项目提供的 Numerical Python 包和其它用于数学和统计学的包。
参看 \textless{}\href{http://scipy.org}{http://scipy.org}\textgreater{}。

当你真的 \emph{真} 想要知道浮点数精确值的时候，Python 提供这样的工具可以帮助你。
\href{https://docs.python.org/3/library/stdtypes.html\#float.as\_integer\_ratio}{float.as\_integer\_ratio()}
方法以分数的形式表示一个浮点数的值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{3.14159}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{as\PYGZus{}integer\PYGZus{}ratio}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(3537115888337719, 1125899906842624)}
\end{Verbatim}

因为比值是精确的，它可以用来无损地重新生成初始值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{3537115888337719} \PYG{o}{/} \PYG{l+m+mi}{1125899906842624}
\PYG{g+go}{True}
\end{Verbatim}

\href{https://docs.python.org/3/library/stdtypes.html\#float.hex}{float.hex()} 方法以十六进制表示浮点数，
给出的同样是计算机存储的精确值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x}\PYG{o}{.}\PYG{n}{hex}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}0x1.921f9f01b866ep+1\PYGZsq{}}
\end{Verbatim}

精确的十六进制表示可以用来准确地重新构建浮点数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x} \PYG{o}{==} \PYG{n+nb}{float}\PYG{o}{.}\PYG{n}{fromhex}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0x1.921f9f01b866ep+1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

因为可以精确表示，所以可以用在不同版本的 Python（与平台相关）之间可靠地移植数据以及与支持同样格式的其它语言
（例如 Java 和 C99）交换数据。

另外一个有用的工具是 \href{https://docs.python.org/3/library/math.html\#math.fsum}{math.fsum()} 函数，
它帮助求和过程中减少精度的损失。当数值在不停地相加的时候，它会跟踪“丢弃的数字”。这可以给总体的准确度带来不同，
以至于错误不会累积到影响最终结果的点:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{1.0}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{math}\PYG{o}{.}\PYG{n}{fsum}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mf}{1.0}
\PYG{g+go}{True}
\end{Verbatim}


\section{表达错误}
\label{floatingpoint:tut-fp-error}\label{floatingpoint:id5}
这一节详细说明 “0.1” 示例，教你怎样自己去精确的分析此类案例。假设这里你已经对浮点数表示有基本的了解。

\emph{Representation error} 提及事实上有些（实际是大多数）十进制小数不能精确的表示为二进制小数。
这是 Python （或 Perl，C，C++，Java，Fortran 以及其它很多）语言往往不能按你期待的样子显示十进制数值的根本原因。

这是为什么？ 1/10 不能精确的表示为二进制小数。大多数今天的机器（2000年十一月）使用 IEEE-754 浮点数算法，
大多数平台上 Python 将浮点数映射为 IEEE-754 “双精度浮点数”。754 双精度包含 53 位精度，
所以计算机努力将输入的 0.1 转为 \emph{J}/2**\emph{N} 最接近的二进制小数。\emph{J} 是一个 53 位的整数。改写:

\begin{Verbatim}[commandchars=\\\{\}]
1 / 10 \PYGZti{}= J / (2**N)
\end{Verbatim}

为:

\begin{Verbatim}[commandchars=\\\{\}]
J \PYGZti{}= 2**N / 10
\end{Verbatim}

\emph{J} 重现时正是 53 位（是 \code{\textgreater{}= 2**52} 而非 \code{\textless{} 2**53} ）， \emph{N} 的最佳值是 56:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{52} \PYG{o}{\PYGZlt{}}\PYG{o}{=}  \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{56} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{10}  \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{53}
\PYG{g+go}{True}
\end{Verbatim}

因此，56 是保持 \emph{J} 精度的唯一 \emph{N} 值。\emph{J} 最好的近似值是整除的商:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q}\PYG{p}{,} \PYG{n}{r} \PYG{o}{=} \PYG{n+nb}{divmod}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{56}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}
\PYG{g+go}{6}
\end{Verbatim}

因为余数大于 10 的一半，最好的近似是取上界:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{q}\PYG{o}{+}\PYG{l+m+mi}{1}
\PYG{g+go}{7205759403792794}
\end{Verbatim}

因此在 754 双精度中 1/10 最好的近似值是是 2**56，或:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7205759403792794} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{56}
\end{Verbatim}

分子和分母都除以2将小数缩小到:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3602879701896397} \PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{55}
\end{Verbatim}

要注意因为我们向上舍入，它其实比 1/10 稍大一点点。如果我们没有向上舍入，
它会比 1/10 稍小一点。但是没办法让它 \emph{恰好} 是 1/10！

所以计算机永远也不 “知道” 1/10：它遇到上面这个小数，给出它所能得到的最佳的 754 双精度实数:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{55}
\PYG{g+go}{7205759403792794.0}
\end{Verbatim}

如果我们把这小数乘以 10**55，我们可以看到其55位十进制数的值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{3602879701896397} \PYG{o}{*} \PYG{l+m+mi}{10} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{55} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{55}
\PYG{g+go}{1000000000000000055511151231257827021181583404541015625}
\end{Verbatim}

这表示存储在计算机中的实际值近似等于十进制值 0.1000000000000000055511151231257827021181583404541015625。
许多语言（包括旧版本的Python）会把结果舍入到 17 位有效数字，而不是显示全部的十进制值:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.17f}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}0.10000000000000001\PYGZsq{}}
\end{Verbatim}

\href{https://docs.python.org/3/library/fractions.html\#module-fractions}{fractions} 和
\href{https://docs.python.org/3/library/decimal.html\#module-decimal}{decimal} 模块使得这些计算很简单:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{decimal} \PYG{k+kn}{import} \PYG{n}{Decimal}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{fractions} \PYG{k+kn}{import} \PYG{n}{Fraction}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fraction}\PYG{o}{.}\PYG{n}{from\PYGZus{}float}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+go}{Fraction(3602879701896397, 36028797018963968)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{as\PYGZus{}integer\PYGZus{}ratio}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{(3602879701896397, 36028797018963968)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Decimal}\PYG{o}{.}\PYG{n}{from\PYGZus{}float}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+go}{Decimal(\PYGZsq{}0.1000000000000000055511151231257827021181583404541015625\PYGZsq{})}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{format}\PYG{p}{(}\PYG{n}{Decimal}\PYG{o}{.}\PYG{n}{from\PYGZus{}float}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.17}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}0.10000000000000001\PYGZsq{}}
\end{Verbatim}


\chapter{附录}
\label{appendix:tut-appendix}\label{appendix::doc}\label{appendix:id1}

\section{交互模式}
\label{appendix:tut-interac}\label{appendix:id2}

\subsection{错误处理}
\label{appendix:tut-error}\label{appendix:id3}
当错误发生时，解释器打印一个错误信息和堆栈跟踪。在交互模式下，它返回主提示符；
当输入来自文件的时候，在打印堆栈跟踪后以非零退出状态退出。
（在 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 声明中
被 \href{https://docs.python.org/3/reference/compound\_stmts.html\#except}{except} 子句捕捉到的异常在这种情况下不是错误。）
有些错误是非常致命的会导致一个非零状态的退出；这也适用于内部错误以及某些情况的内存耗尽。
所有的错误信息都写入到标准错误流；来自执行的命令的普通输出写入到标准输出。

输入中断符（通常是 Control-C 或者 DEL）到主或者从提示符中会取消输入并且返回到主提示。
\footnote{
GNU 的 Readline 包的问题可能会阻止这种做法。
} 当命令执行中输入中断符会引起 \href{https://docs.python.org/3/library/exceptions.html\#KeyboardInterrupt}{KeyboardInterrupt}
异常，这个异常能够被一个 \href{https://docs.python.org/3/reference/compound\_stmts.html\#try}{try} 声明处理。


\subsection{可执行 Python 脚本}
\label{appendix:python}\label{appendix:tut-scripts}
在 BSD'ish Unix 系统上，Python 脚本可直接执行，像 shell 脚本一样，只需要把下面内容加入到

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}!/usr/bin/env python3.4}
\end{Verbatim}

（假设 python 解释器在用户的 \index{PATH}\index{环境变量!PATH}\code{PATH} 中）脚本的开头，并给予该文件的可执行模式。
\code{\#!} 必须是文件的头两个字符。在一些系统上，第一行必须以 Unix-style 的行结束符（\code{'\textbackslash{}n'}）结束，
不能以 Windows 的行结束符（\code{'\textbackslash{}r\textbackslash{}n'}）。 注意 \code{'\#'} 在 Python 中是用于注释的。

使用 \textbf{\texttt{chmod}} 命令能够给予脚本执行模式或者权限。

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }chmod +x myscript.py
\end{Verbatim}

在 Windows 系统上，没有一个 “可执行模式” 的概念。Python 安装器会自动地把 \code{.py}  文件和 \code{python.exe} 关联起来，
因此双击 Python 分拣将会把它当成一个脚本运行。文件扩展名也可以是 \code{.pyw}，在这种情况下，运行时不会出现控制台窗口。


\subsection{交互式启动文件}
\label{appendix:id6}\label{appendix:tut-startup}
当你使用交互式 Python 的时候，它常常很方便地执行一些命令在每次解释器启动时。你可以这样做：
设置一个名为 \href{https://docs.python.org/3/using/cmdline.html\#envvar-PYTHONSTARTUP}{PYTHONSTARTUP} 的环境变量
为包含你的启动命令的文件名。这跟 Unix shells 的 \code{.profile} 特点有些类似。

这个文件在交互式会话中是只读的，在当 Python 从脚本中读取命令，以及在当 \code{/dev/tty} 被作为明确的命令源的时候
不只是可读的。该文件在交互式命令被执行的时候在相同的命名空间中能够被执行，因此在交互式会话中定义或者导入的对象
能够无需授权就能使用。你也能在文件中更改提示 \code{sys.ps1} 和 \code{sys.ps2}。

如果你想要从当前目录中读取一个附加的启动文件，你可以在全局启动文件中编写代码像这样：\code{if
os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())}。如果你想要在脚本中使用启动文件的话，
你必须在脚本中明确要这么做:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{filename} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{PYTHONSTARTUP}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{filename} \PYG{o+ow}{and} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)} \PYG{k}{as} \PYG{n}{fobj}\PYG{p}{:}
       \PYG{n}{startup\PYGZus{}file} \PYG{o}{=} \PYG{n}{fobj}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{exec}\PYG{p}{(}\PYG{n}{startup\PYGZus{}file}\PYG{p}{)}
\end{Verbatim}


\subsection{定制模块}
\label{appendix:id7}\label{appendix:tut-customize}
Python 提供两个钩子为了让你们定制 \code{sitecustomize} 和 \code{usercustomize}。为了看看它的工作机制的话，
你必须首先找到你的用户 site-packages 目录的位置。启动 Python 并且运行这段代码:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{site}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{site}\PYG{o}{.}\PYG{n}{getusersitepackages}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}/home/user/.local/lib/python3.4/site\PYGZhy{}packages\PYGZsq{}}
\end{Verbatim}

现在你可以创建一个名为 \code{usercustomize.py} 的文件在你的用户 site-packages 目录，
并且在里面放置你想要的任何内容。它会影响 Python 的每一次调用，
除非它以 \href{https://docs.python.org/3/using/cmdline.html\#cmdoption-s}{-s} （禁用自动导入）选项启动。

\code{sitecustomize} 以同样地方式工作，但是通常由是机器的管理员创建在全局的 site-packages 目录中，
并且是在 \code{usercustomize} 之前导入。请参阅 \href{https://docs.python.org/3/library/site.html\#module-site}{site}
模块获取更多信息。



\renewcommand{\indexname}{索引}
\printindex
\end{document}
